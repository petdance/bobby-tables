# Header entry was created by KBabel!
#
# This site's content is available under the Creative Commons Attribution-ShareAlike 3.0 License.
# Lars Dɪᴇᴄᴋᴏᴡ 迪拉斯 <daxim@cpan.org>, 2010, 2012.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: YEAR-MO-DA HO:MI+ZONE\n"
"PO-Revision-Date: 2012-05-01 22:53+0200\n"
"Last-Translator: Lars Dɪᴇᴄᴋᴏᴡ <daxim@cpan.org>\n"
"Language-Team: German <>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Lokalize 1.4\n"
"Plural-Forms: nplurals=2; plural=n != 1;\n"

#: crank.pl:30
msgid "Home"
msgstr "Übersicht"

#: crank.pl:31
msgid "Translations"
msgstr "Übersetzungen"

#: crank.pl:32
msgid "About"
msgstr "Über"

#: s/about.md.tt2:1
msgid "# About Bobby Tables and SQL injection"
msgstr "# Über Bobby Tables und SQL-Einschleusung"

#: s/about.md.tt2:3
msgid "# Why did Bobby's school lose their records?"
msgstr "# Warum hat Bobbys Schule ihre Daten verloren?"

#: s/about.md.tt2:5
msgid ""
"The school apparently stores the names of their students in a table called "
"Students. When a new student arrives, the school inserts his/her name into "
"this table. The code doing the insertion might look as follows:"
msgstr ""
"Die Schule hat anscheinend die Namen der Schüler in einer Tabelle namens "
"`Students` gespeichert. Wenn sich ein neuer Schüler anmeldet, fügt die "
"Schule seinen Namen zur Tabelle hinzu. Der dazugehörige Code könnte etwa "
"so ausschauen:"

#: s/about.md.tt2:7
msgid ""
"    $sql = \"INSERT INTO Students (Name) VALUES ('\" . $studentName . \"');"
"\";\n"
"    execute_sql($sql);"
msgstr ""
"    $sql = \"INSERT INTO Students (Name) VALUES ('\" . $studentName . \"');"
"\";\n"
"    execute_sql($sql);"

#: s/about.md.tt2:10
msgid ""
"The first line creates a string containing an SQL INSERT statement. The "
"content of the `$studentName` variable is glued into the SQL statement. The "
"second line sends the resulting SQL statement to the database. The pitfall "
"of this code is that outside data, in this case the content of `"
"$studentName`, becomes part of the SQL statement."
msgstr ""
"Die erste Zeile erzeugt einen String mit einem SQL-INSERT-Anweisung. Der "
"Inhalt der Variable `$studentName` wird in die SQL-Anweisung eingefügt. Die "
"zweite Zeile schickt die erzeugte SQL-Anweisung an die Datenbank. Die Falle "
"in diesem Code ist, dass Daten von außerhalb, d.h. der Inhalt von "
"`$studentName`, Teil der SQL-Anweisung werden."

#: s/about.md.tt2:12
msgid ""
"First let's see what the SQL statement looks like if we insert a student "
"named John:"
msgstr ""
"Wir betrachten zunächst, wie die SQL-Anweisung aussieht, wenn wir einen "
"Schüler namens John hinzufügen:"

#: s/about.md.tt2:14
msgid "    INSERT INTO Students (Name) VALUES ('John');"
msgstr "    INSERT INTO Students (Name) VALUES ('John');"

#: s/about.md.tt2:16
msgid ""
"This does exactly what we want: it inserts John into the Students table."
msgstr ""
"Das ergibt genau, was wir wollen: John wird der Tabelle `Students` "
"hinzugefügt."

#: s/about.md.tt2:18
msgid ""
"Now we insert little Bobby Tables, by setting `$studentName` to `Robert'); "
"DROP TABLE Students;--`. The SQL statement becomes:"
msgstr ""
"Jetzt fügen wir Klein Bobby Tables hinzu, indem wir `$studentName` den "
"Wert `Robert'); DROP TABLE Students;--` zuweisen. Die SQL-Anweisung lautet:"

#: s/about.md.tt2:20
msgid ""
"    INSERT INTO Students (Name) VALUES ('Robert'); DROP TABLE Students;--');"
msgstr ""
"    INSERT INTO Students (Name) VALUES ('Robert'); DROP TABLE Students;--');"

#: s/about.md.tt2:22
msgid ""
"This inserts Robert into the Students table. However, the INSERT statement "
"is now followed by a DROP TABLE statement which removes the entire Students "
"table. Ouch!"
msgstr ""
"Dies fügt Robert der Tabelle `Students` hinzu, jedoch folgt der "
"INSERT-Anweisung eine DROP-TABLE-Anweisung, die die gesamte Tabelle "
"entfernt. Autsch!"

#: s/about.md.tt2:24
msgid ""
"\n"
"# How to avoid Bobby Tables"
msgstr ""
"\n"
"# Wie man Bobby Tables vermeidet"

#: s/about.md.tt2:27
msgid "There is only one way to avoid Bobby Tables attacks"
msgstr "Man kann Bobby-Tables-Angriffe nur vermeiden,"

#: s/about.md.tt2:29
msgid ""
"* Do not create SQL statements that include outside data.\n"
"* Use parameterized SQL calls."
msgstr ""
"* indem man keine SQL-Anweisungen erstellt, die von außen kommende Daten "
"enthalten.\n"
"* indem man SQL-Aufrufe mit Parametern tätigt."

#: s/about.md.tt2:32
msgid ""
"That's it. Don't try to escape invalid characters. Don't try to do it "
"yourself. Learn how to use parameterized statements. Always, every single "
"time."
msgstr ""
"Das ist alles. Nicht versuchen, ungültige Zeichen zu maskieren. Nicht "
"versuchen, es eigenhändig zu machen. Lerne, parameterisierte Anweisungen zu "
"benutzen, und zwar immer und jedes Mal."

#: s/about.md.tt2:34
msgid ""
"The strip gets one thing crucially wrong. The answer is not to \"sanitize "
"your database inputs\" yourself. It is prone to error.\n"
msgstr ""
"Im Comic wird eine Sache falsch gemacht. Die Antwort lautet nicht, die "
"Datenbankeingaben selber zu bereinigen. Dies ist fehleranfällig.\n"

#: s/asp.md.tt2:1
msgid ""
"ASP\n"
"==="
msgstr ""
"ASP\n"
"==="

#: s/asp.md.tt2:4
msgid "Older ASP uses positional placeholders."
msgstr "Ältere Versionen von ASP benutzen Ordnungsplatzhalter."

#: s/asp.md.tt2:6
msgid ""
"    objCmd.CommandType = adCmdText;\n"
"    objCmd.CommandText = \"UPDATE members SET photo = ? WHERE memberID = ?"
"\";\n"
"    objCmd.Parameters.Append(objCmd.CreateParameter(\"filename\", adVarChar, "
"adParamInput, 510, fileName));\n"
"    objCmd.Parameters.Append(objCmd.CreateParameter(\"memberID\", adInteger, "
"adParamInput, 4, memberid ));\n"
"    objCmd.Execute(adExecuteNoRecords);"
msgstr ""
"    objCmd.CommandType = adCmdText;\n"
"    objCmd.CommandText = \"UPDATE members SET photo = ? WHERE memberID = ?"
"\";\n"
"    objCmd.Parameters.Append(objCmd.CreateParameter(\"filename\", adVarChar, "
"adParamInput, 510, fileName));\n"
"    objCmd.Parameters.Append(objCmd.CreateParameter(\"memberID\", adInteger, "
"adParamInput, 4, memberid ));\n"
"    objCmd.Execute(adExecuteNoRecords);"

#: s/asp.md.tt2:12
msgid ""
"\n"
"Newer ASP (ASP.Net?) can handle named placeholders."
msgstr ""
"\n"
"Neuere Versionen von ASP (ASP.Net?) können mit benannten Platzhaltern umgehen."

#: s/asp.md.tt2:15
msgid ""
"    objCmd.CommandType = adCmdText;\n"
"    objCmd.CommandText = \"UPDATE members SET photo = @filename WHERE "
"memberID = @memberID\";\n"
"    objCmd.Parameters.Append(objCmd.CreateParameter(\"@memberID\", "
"adInteger, adParamInput, 4, memberid ));\n"
"    objCmd.Parameters.Append(objCmd.CreateParameter(\"@filename\", "
"adVarChar, adParamInput, 510, fileName));\n"
"    objCmd.Execute(adExecuteNoRecords);\n"
"    gblDelobjParams(objCmd);"
msgstr ""
"    objCmd.CommandType = adCmdText;\n"
"    objCmd.CommandText = \"UPDATE members SET photo = @filename WHERE "
"memberID = @memberID\";\n"
"    objCmd.Parameters.Append(objCmd.CreateParameter(\"@memberID\", "
"adInteger, adParamInput, 4, memberid ));\n"
"    objCmd.Parameters.Append(objCmd.CreateParameter(\"@filename\", "
"adVarChar, adParamInput, 510, fileName));\n"
"    objCmd.Execute(adExecuteNoRecords);\n"
"    gblDelobjParams(objCmd);"

#: s/asp.md.tt2:22 s/dotnet.md.tt2:13 s/perl.md.tt2:43 s/python.md.tt2:14
#: s/ruby.md.tt2:15 s/scheme.md.tt2:15
msgid ""
"To do\n"
"-----"
msgstr ""
"In Vorbereitung\n"
"---------------"

#: s/asp.md.tt2:25
msgid "Add some narrative\n"
msgstr "Mehr Erläuterung\n"

#: s/coldfusion.md.tt2:1
msgid ""
"ColdFusion\n"
"=========="
msgstr ""
"ColdFusion\n"
"=========="

#: s/coldfusion.md.tt2:4
msgid ""
"In ColdFusion there is a tag called `cfqueryparam` that should be used "
"whenever writing inline queries."
msgstr ""
"In ColdFusion gibt es eine Funktion `cfqueryparam`, die immer benutzt werden "
"sollte, um eingebettete Abfragen zu schreiben."

#: s/coldfusion.md.tt2:6
msgid ""
"    <cfquery name=\"queryTest\">\n"
"    SELECT FirstName, LastName, Phone\n"
"    FROM   tblUser\n"
"    WHERE  Status =\n"
"      <cfqueryparam cfsqltype=\"CF_SQL_VARCHAR\" value=\"#form.status#\">\n"
"    </cfquery>"
msgstr ""
"    <cfquery name=\"queryTest\">\n"
"    SELECT FirstName, LastName, Phone\n"
"    FROM   tblUser\n"
"    WHERE  Status =\n"
"      <cfqueryparam cfsqltype=\"CF_SQL_VARCHAR\" value=\"#form.status#\">\n"
"    </cfquery>"

#: s/coldfusion.md.tt2:13
msgid ""
"\n"
"Stored procedures can be invoked with the `cfstoredproc` and `cfprocparam` "
"tags."
msgstr ""
"\n"
"Wenn man gespeicherte Prozeduren in der Datenbank hat, kann man sie mit den "
"Funktionen `cfstoredproc` und `cfprocparam` aufrufen."

#: s/coldfusion.md.tt2:16
msgid ""
"Recent versions of ColdFusion provide a set of functions to run queries "
"that\n"
"have a slightly different syntax, but still provide parameterized queries."
msgstr ""
"Neuere Versionen von ColdFusion haben Funktionen,\n"
"um Abfragen mit einer leicht veränderten Syntax durchzuführen,\n"
"die aber dennoch parameterisierte Abfragen haben."

#: s/coldfusion.md.tt2:19
msgid ""
"\n"
"    <cfscript>\n"
"      var myQuery = new Query(sql=\"\n"
"        SELECT FirstName, LastName, Phone\n"
"        FROM   tblUser\n"
"        WHERE  Status = :status\n"
"      \");\n"
"      myQuery.addParam(\n"
"        name      = \"status\",\n"
"        value     = form.status,\n"
"        cfsqltype = \"cf_sql_varchar\"\n"
"      );\n"
"      var rawQuery = myQuery.execute().getResult();\n"
"    </cfscript>"
msgstr ""
"\n"
"    <cfscript>\n"
"      var myQuery = new Query(sql=\"\n"
"        SELECT FirstName, LastName, Phone\n"
"        FROM   tblUser\n"
"        WHERE  Status = :status\n"
"      \");\n"
"      myQuery.addParam(\n"
"        name      = \"status\",\n"
"        value     = form.status,\n"
"        cfsqltype = \"cf_sql_varchar\"\n"
"      );\n"
"      var rawQuery = myQuery.execute().getResult();\n"
"    </cfscript>"

#: s/csharp.md.tt2:1
msgid ""
"C\\#\n"
"==="
msgstr ""
"C\\#\n"
"==="

#: s/csharp.md.tt2:4
msgid ""
"From the [C# Online](http://en.csharp-online.net/) wiki page [ASP.NET "
"Security Hacks--Avoiding SQL Injection](http://en.csharp-online.net/ASP."
"NET_Security_Hacks%E2%80%94Avoiding_SQL_Injection)"
msgstr ""
"[ASP.NET Security Hacks — Avoiding SQL Injection](http://en.csharp-online."
"net/ASP.NET_Security_Hacks%E2%80%Avoiding_SQL_Injection) aus dem [C#-Online-"
"Wiki](http://en.csharp-online.net/)"

#: s/csharp.md.tt2:6
msgid ""
"\n"
"    SqlCommand userInfoQuery = new SqlCommand(\n"
"        \"SELECT id, name, email FROM users WHERE id = @UserName\",\n"
"        someSqlConnection);"
msgstr ""
"\n"
"    SqlCommand userInfoQuery = new SqlCommand(\n"
"        \"SELECT id, name, email FROM users WHERE id = @UserName\",\n"
"        someSqlConnection);"

#: s/csharp.md.tt2:11
msgid ""
"    SqlParameter userNameParam = userInfoQuery.Parameters.Add(\"@UserName"
"\",\n"
"        SqlDbType.VarChar, 25 /* max length of field */ );"
msgstr ""
"    SqlParameter userNameParam = userInfoQuery.Parameters.Add(\"@UserName"
"\",\n"
"        SqlDbType.VarChar, 25 /* max length of field */ );"

#: s/csharp.md.tt2:14
msgid ""
"    // userName is some string valued user input variable\n"
"    userNameParam.Value = userName;"
msgstr ""
"    // userName ist eine vom Benutzer eingegebene Stringvariable\n"
"    userNameParam.Value = userName;"

#: s/csharp.md.tt2:17
msgid "Or simpler:"
msgstr "Oder einfacher:"

#: s/csharp.md.tt2:19
msgid ""
"\n"
"    String username = \"joe.bloggs\";\n"
"    SqlCommand sqlQuery = new SqlCommand(\"SELECT user_id, first_name,"
"last_name FROM users WHERE username = ?username\",  sqlConnection);\n"
"    sqlQuery.Parameters.AddWithValue(\"?username\", username);\n"
msgstr ""
"\n"
"    String username = \"joe.bloggs\";\n"
"    SqlCommand sqlQuery = new SqlCommand(\"SELECT user_id, first_name,"
"last_name FROM users WHERE username = ?username\",  sqlConnection);\n"
"    sqlQuery.Parameters.AddWithValue(\"?username\", username);\n"

#: s/delphi.md.tt2:1
msgid ""
"Delphi\n"
"======"
msgstr ""
"Delphi\n"
"======"

#: s/delphi.md.tt2:4
msgid "To use a prepared statement, do something like this:"
msgstr "Um eine vorbereitete Anweisung zu benutzen:"

#: s/delphi.md.tt2:6
msgid ""
"    query.SQL.Text := 'update people set name=:Name where id=:ID';\n"
"    query.Prepare;\n"
"    query.ParamByName( 'Name' ).AsString := name;\n"
"    query.ParamByName( 'ID' ).AsInteger := id;\n"
"    query.ExecSQL;\n"
msgstr ""
"    query.SQL.Text := 'update people set name=:Name where id=:ID';\n"
"    query.Prepare;\n"
"    query.ParamByName( 'Name' ).AsString := name;\n"
"    query.ParamByName( 'ID' ).AsInteger := id;\n"
"    query.ExecSQL;\n"

#: s/dotnet.md.tt2:1
msgid ""
".NET\n"
"===="
msgstr ""
".NET\n"
"===="

#: s/dotnet.md.tt2:4
msgid "Reference:"
msgstr "Literaturhinweis:"

#: s/dotnet.md.tt2:6
msgid ""
"-    [SqlCommand.Prepare](http://msdn.microsoft.com/en-us/library/system."
"data.sqlclient.sqlcommand.prepare.aspx) in the .NET Framework Class Library"
msgstr ""
"-   [SqlCommand.Prepare](http://msdn.microsoft.com/en-us/library/system.data."
"sqlclient.sqlcommand.prepare.aspx) in der Klassenbibliothek des .NET-"
"Framework"

#: s/dotnet.md.tt2:8
msgid "Articles:"
msgstr "Artikel:"

#: s/dotnet.md.tt2:10
msgid ""
"-   [SQL injection](http://msdn.microsoft.com/en-us/library/ms161953.aspx) "
"on MSDN\n"
"-   [SQL Injection and how to avoid it](http://blogs.msdn.com/tom/"
"archive/2008/05/29/sql-injection-and-how-to-avoid-it.aspx) on the ASP.NET "
"Debugging blog"
msgstr ""
"-   [SQL injection](http://msdn.microsoft.com/en-us/library/ms161953.aspx) "
"auf MSDN\n"
"-   [SQL Injection and how to avoid it](http://blogs.msdn.com/tom/"
"archive/2008/05/29/sql-injection-and-how-to-avoid-it.aspx) auf dem Blog "
"\"ASP.NET Debugging\""

#: s/dotnet.md.tt2:16
msgid ""
"-   Add some narrative\n"
"-   Show code examples\n"
msgstr ""
"-   Mehr Erläuterung\n"
"-   Codebeispiele zeigen\n"

#: s/index.md.tt2:1
msgid ""
"Who is Bobby Tables?\n"
"===================="
msgstr ""
"Wer ist Bobby Tables?\n"
"====================="

#: s/index.md.tt2:4
msgid "[From the webcomic _xkcd_](http://xkcd.com/327/)"
msgstr "[Vom Webcomic _xkcd_](http://xkcd.com/327/)"

#: s/index.md.tt2:6
msgid ""
"<a href=\"http://xkcd.com/327/\"><img src=\"/img/xkcd.png\" alt=\"xkcd Bobby "
"Tables Cartoon\" height=\"205\" width=\"666\" /></a>"
msgstr ""
"<a href=\"http://xkcd.com/327/\"><img src=\"/img/xkcd.png\" alt=\"xkcd-"
"Comic &quot;Bobby Tables&quot;\" height=\"205\" width=\"666\" /></a>"

#: s/index.md.tt2:8
msgid "<br clear=\"right\">"
msgstr "<br clear=\"right\">"

#: s/index.md.tt2:10
msgid ""
"**School**: Hi, this is your son's school. We're having some computer "
"trouble."
msgstr ""
"**Schule**: Hallo, hier spricht die Schule Ihres Sohnes. Wir haben "
"Computerprobleme."

#: s/index.md.tt2:12
msgid "**Mom**: Oh, dear -- Did he break something?"
msgstr "**Mutter**: Auweia – hat er etwas kaputtgemacht?"

#: s/index.md.tt2:14
msgid ""
"**School**: In a way. Did you really name your son `Robert'); DROP TABLE "
"Students;--`?"
msgstr ""
"**Schule**: So ähnlich. Haben sie Ihren Sohn wirklich `Robert'); DROP TABLE "
"Students;--` genannt?"

#: s/index.md.tt2:16
msgid "**Mom**: Oh. Yes. Little Bobby Tables we call him."
msgstr "**Mutter**: Oh. Ja. Wir rufen ihn Klein Bobby Tables."

#: s/index.md.tt2:18
msgid ""
"**School**: Well, we've lost this year's student records. I hope you're "
"happy."
msgstr ""
"**Schule**: Also, der Datenbestand der Schüler dieses Jahres ist futsch. Ich "
"hoffe, Sie sind jetzt glücklich."

#: s/index.md.tt2:20
msgid "**Mom**: And I hope you've learned to sanitize your database inputs."
msgstr ""
"**Mutter**: Und ich hoffe, Sie haben gelernt, Datenbankeingaben zu "
"bereinigen."

#: s/index.md.tt2:24
msgid ""
"Examples\n"
"========"
msgstr ""
"Beispiele\n"
"========="

#: s/index.md.tt2:27
msgid "See the sidebar to the left for your specific language."
msgstr "Siehe Kasten links für die jeweilige Sprache."

#: s/index.md.tt2:29
msgid ""
"Other random resources\n"
"======================"
msgstr ""
"Andere wahllose Ressourcen\n"
"=========================="

#: s/index.md.tt2:32
msgid ""
"* [SQL Injection Myths and Fallacies](http://www.slideshare.net/billkarwin/"
"sql-injection-myths-and-fallacies)\n"
"* [How to Write Injection-Proof SQL](http://www.schneier.com/blog/"
"archives/2008/10/how_to_write_in.html)\n"
"* [Defending Against SQL Injection Attacks](http://download.oracle.com/oll/"
"tutorials/SQLInjection/index.htm)"
msgstr ""
"* [SQL Injection Myths and Fallacies](http://www.slideshare.net/billkarwin/"
"sql-injection-myths-and-fallacies)\n"
"* [How to Write Injection-Proof SQL](http://www.schneier.com/blog/"
"archives/2008/10/how_to_write_in.html)\n"
"* [Defending Against SQL Injection Attacks](http://download.oracle.com/oll/"
"tutorials/SQLInjection/index.htm)"

#: s/index.md.tt2:36
msgid ""
"Patches welcome\n"
"==============="
msgstr ""
"Verbesserungen sind willkommen\n"
"=============================="

#: s/index.md.tt2:39
msgid ""
"Don't see a language that you'd like to see represented? Please let me know "
"if you have updates or additions through one of these methods, in decreasing "
"order of preference."
msgstr ""
"Wird eine Sprache vermisst? Bitte melde Verbesserungen oder Ergänzungen auf "
"eine dieser drei Arten, in absteigender Reihenfolge der Bevorzugung."

#: s/index.md.tt2:41
msgid ""
"* Fork the [bobby-tables repository at github](http://github.com/petdance/"
"bobby-tables), make your changes, and send me a pull request.\n"
"* Add an issue in the [issue tracker](http://github.com/petdance/bobby-"
"tables/issues).\n"
"* Email me, Andy Lester, at andy at petdance.com."
msgstr ""
"* Erstelle einen Fork vom [Repository bobby-tables auf github](http://github."
"com/petdance/bobby-tables), füge die Änderungen hinzu und schicke mir einen "
"Pull-Request.\n"
"* Erstelle eine Anfrage im [Fallbearbeitungssystem](http://github.com/"
"petdance/bobby-tables/issues).\n"
"* Schicke mir eine Email: Andy Lester, andy at petdance.com."

#: s/index.md.tt2:45
msgid ""
"Translations also welcome\n"
"========================="
msgstr ""
"Übersetzungen sind auch willkommen\n"
"=================================="

#: s/index.md.tt2:48
msgid ""
"Help translate this site! There are less than 200 phrases. No programming "
"necessary."
msgstr ""
"Hilf mit, diesen Webauftritt zu übersetzen! Es sind weniger als 200 "
"Ausdrücke. Keine Programmierung notwendig."

#: s/index.md.tt2:50
msgid ""
"See the instructions at the [bobby-tables repository at github](http://"
"github.com/petdance/bobby-tables#readme)."
msgstr ""
"Siehe Anleitung im [Repository bobby-tables auf github](http://github.com/"
"petdance/bobby-tables#readme)."

#: s/index.md.tt2:52
msgid ""
"To do\n"
"====="
msgstr ""
"In Vorbereitung\n"
"==============="

#: s/index.md.tt2:55
msgid ""
"* Explain why creating code from outside data is bad.\n"
"* Potential speed win when reusing prepared statements."
msgstr ""
"* Erklärung, warum es schlecht ist, Anweisung auf Grundlage von außerhalb "
"kommender Daten zu erzeugen.\n"
"* Möglicher Geschwindigkeitszuwachs unter Wiederverwendung vorbereiteter "
"Anweisungen."

#: s/index.md.tt2:58
msgid ""
"Thanks\n"
"======"
msgstr ""
"Danksagung\n"
"=========="

#: s/index.md.tt2:61
msgid "Thanks to the following folks for their contributions:"
msgstr "Dank gilt den folgenden Leuten für ihre Mitwirkung:"

#: s/index.md.tt2:63
msgid ""
"* [Kim Christensen](http://www.smukkekim.dk)\n"
"* Kirk Kimmel\n"
"* Nathan Mahdavi\n"
"* [Hannes Hofmann](http://www5.informatik.uni-erlangen.de/en/our-team/"
"hofmann-hannes)\n"
"* [Mike Angstadt](http://www.mangst.com)\n"
"* [Peter Ward](http://identi.ca/flowblok/)\n"
"* [David Wheeler](http://justatheory.com)\n"
"* Scott Rose\n"
"* Erik Osheim\n"
"* Russ Sivak\n"
"* [Iain Collins](http://iaincollins.com)\n"
"* Kristoffer Sall Hansen\n"
"* Jeff Emminger\n"
"* [Travis Swicegood](http://www.travisswicegood.com/)\n"
"* [Will Coleda](http://www.coleda.com/users/coke/)\n"
"* Kai Baesler\n"
"* Mike Markley\n"
"* [Michael Schwern](http://schwern.net/)\n"
"* [Jeana Clark](http://jeanaclark.org/)\n"
"* [Lars Dɪᴇᴄᴋᴏᴡ](http://search.cpan.org/~daxim/)\n"
"* [Jani Hur](http://www.jani-hur.net)\n"
"* [Sven van Haastregt](http://www.liacs.nl/home/svhaastr/)\n"
msgstr ""
"* [Kim Christensen](http://www.smukkekim.dk)\n"
"* Kirk Kimmel\n"
"* Nathan Mahdavi\n"
"* [Hannes Hofmann](http://www5.informatik.uni-erlangen.de/en/our-team/"
"hofmann-hannes)\n"
"* [Mike Angstadt](http://www.mangst.com)\n"
"* [Peter Ward](http://identi.ca/flowblok/)\n"
"* [David Wheeler](http://justatheory.com)\n"
"* Scott Rose\n"
"* Erik Osheim\n"
"* Russ Sivak\n"
"* [Iain Collins](http://iaincollins.com)\n"
"* Kristoffer Sall Hansen\n"
"* Jeff Emminger\n"
"* [Travis Swicegood](http://www.travisswicegood.com/)\n"
"* [Will Coleda](http://www.coleda.com/users/coke/)\n"
"* Kai Baesler\n"
"* Mike Markley\n"
"* [Michael Schwern](http://schwern.net/)\n"
"* [Jeana Clark](http://jeanaclark.org/)\n"
"* [Lars Dɪᴇᴄᴋᴏᴡ](http://search.cpan.org/~daxim/)\n"
"* [Jani Hur](http://www.jani-hur.net)\n"
"* [Sven van Haastregt](http://www.liacs.nl/home/svhaastr/)\n"

#: s/java.md.tt2:1
msgid ""
"Java\n"
"===="
msgstr ""
"Java\n"
"===="

#: s/java.md.tt2:4
msgid ""
"JDBC\n"
"----"
msgstr ""
"JDBC\n"
"----"

#: s/java.md.tt2:7
msgid ""
"The [JDBC API](http://download.oracle.com/javase/tutorial/jdbc/index.html)\n"
"has a class called\n"
"[`PreparedStatement`](http://download.oracle.com/javase/6/docs/api/java/sql/"
"PreparedStatement.html)\n"
"which allows the programmer to safely insert user-supplied data\n"
"into a SQL query.  The location of each input value in the query\n"
"string is marked with a question mark.  The various `set*()` methods\n"
"are then used to safely perform the insertion."
msgstr ""
"Die [JDBC-API](http://download.oracle.com/javase/tutorial/jdbc/index.html)\n"
"enthält eine Klasse [`PreparedStatement`](http://download.oracle.com/"
"javase/6/docs/api/java/sql/PreparedStatement.html), die Benutzereingaben "
"sicher in eine SQL-Abfrage einfügt.\n"
"Der Ort jedes Eingabewerts im Abfragestring ist durch ein Fragezeichen\n"
"markiert. Die diversen Methoden `set*()` werden dann benutzt, um sicher\n"
"einzufügen."

#: s/java.md.tt2:15
msgid ""
"    String name = //user input\n"
"    int age = //user input\n"
"    Connection connection = DriverManager.getConnection(...);\n"
"    PreparedStatement statement = connection.prepareStatement(\n"
"            \"SELECT * FROM people WHERE lastName = ? AND age > ?\" );\n"
"    statement.setString(1, name); //lastName is a VARCHAR\n"
"    statement.setInt(2, age); //age is an INT\n"
"    ResultSet rs = statement.executeQuery();\n"
"    while (rs.next()){\n"
"        //...\n"
"    }"
msgstr ""
"    String name = //Benutzereingabe\n"
"    int age = //Benutzereingabe\n"
"    Connection connection = DriverManager.getConnection(...);\n"
"    PreparedStatement statement = connection.prepareStatement(\n"
"            \"SELECT * FROM people WHERE lastName = ? AND age > ?\" );\n"
"    statement.setString(1, name); //lastName is a VARCHAR\n"
"    statement.setInt(2, age); //age is an INT\n"
"    ResultSet rs = statement.executeQuery();\n"
"    while (rs.next()){\n"
"        //...\n"
"    }"

#: s/java.md.tt2:27
msgid ""
"\n"
"Once a `PreparedStatement` object has been created, it can be reused\n"
"multiple times for multiple queries (for example, when using the\n"
"same query to update multiple rows in a table).  However, they are\n"
"**not thread-safe** because of the many method calls involved in\n"
"setting the parameters and executing the query.  Therefore, you\n"
"should only define `PreparedStatement` objects as method-level\n"
"variables (as opposed to class-level variables) to avoid concurrency\n"
"issues."
msgstr ""
"\n"
"Nachdem ein Objekt vom Typ `PreparedStatement` erzeugt wurde, kann es\n"
"mehrfach für Abfragen wiederverwendet werden (z.B. wenn dieselbe Abfrage\n"
"mehrere Zeilen in einer Tabelle aktualisiert). Aber sie sind wegen der\n"
" vielen Methodenaufrufe, die die Parameter setzen und die Abfrage\n"
"ausführen, **nicht threadsicher**. Deswegen sollte man Objekte vom Typ\n"
"`PreparedStatement` nur als methodensichtbare Variablen (im Gegensatz\n"
"zu klassensichtbaren Variablen) definieren, um Nebenläufigkeitsprobleme\n"
"zu vermeiden."

#: s/java.md.tt2:37
msgid ""
"    List<Person>; people = //user input\n"
"    Connection connection = DriverManager.getConnection(...);\n"
"    connection.setAutoCommit(false);\n"
"    try {\n"
"        PreparedStatement statement = connection.prepareStatement(\n"
"                \"UPDATE people SET lastName = ?, age = ? WHERE id = ?\");\n"
"        for (Person person : people){\n"
"            statement.setString(1, person.getLastName());\n"
"            statement.setInt(2, person.getAge());\n"
"            statement.setInt(3, person.getId());\n"
"            statement.execute();\n"
"        }\n"
"        connection.commit();\n"
"    } catch (SQLException e) {\n"
"        connection.rollback();\n"
"    }"
msgstr ""
"    List<Person>; people = //Benutzereingabe\n"
"    Connection connection = DriverManager.getConnection(...);\n"
"    connection.setAutoCommit(false);\n"
"    try {\n"
"        PreparedStatement statement = connection.prepareStatement(\n"
"                \"UPDATE people SET lastName = ?, age = ? WHERE id = ?\");\n"
"        for (Person person : people){\n"
"            statement.setString(1, person.getLastName());\n"
"            statement.setInt(2, person.getAge());\n"
"            statement.setInt(3, person.getId());\n"
"            statement.execute();\n"
"        }\n"
"        connection.commit();\n"
"    } catch (SQLException e) {\n"
"        connection.rollback();\n"
"    }"

#: s/java.md.tt2:54
msgid ""
"More information on `PreparedStatement` can be found in the\n"
"[Oracle JDBC tutorial](http://download.oracle.com/javase/tutorial/jdbc/"
"basics/prepared.html)."
msgstr ""
"Weitere Informationen über `PreparedStatement` sind in der\n"
"[Oracle-JDBC-Anleitung](http://download.oracle.com/javase/tutorial/jdbc/"
"basics/prepared.html)\n"
"zu finden."

#: s/java.md.tt2:57
msgid ""
"Hibernate\n"
"---------"
msgstr ""
"Hibernate\n"
"---------"

#: s/java.md.tt2:60
msgid ""
"[Hibernate](http://www.hibernate.org/) uses named parameters to\n"
"safely insert data into a query.  A named parameter consists of a\n"
"colon, followed by a unique name for the parameter."
msgstr ""
"[Hibernate](http://www.hibernate.org/) benutzt benannte Parameter,\n"
"um Daten sicher in eine Abfrage einzufügen. Ein benannter Parameter\n"
"besteht aus einem Doppelpunkt gefolgt von einem eindeutigen Namen\n"
"für den Parameter."

#: s/java.md.tt2:64
msgid ""
"    String name = //user input\n"
"    int age = //user input\n"
"    Session session = //...\n"
"    Query query = session.createQuery(\"from People where lastName = :name "
"and age > :age\");\n"
"    query.setString(\"name\", name);\n"
"    query.setInteger(\"age\", age);\n"
"    Iterator people = query.iterate();"
msgstr ""
"    String name = //Benutzereingabe\n"
"    int age = //Benutzereingabe\n"
"    Session session = //...\n"
"    Query query = session.createQuery(\"from People where lastName = :name "
"and age > :age\");\n"
"    query.setString(\"name\", name);\n"
"    query.setInteger(\"age\", age);\n"
"    Iterator people = query.iterate();"

#: s/java.md.tt2:72
msgid ""
"Hibernate also supports positional parameters like `PreparedStatement`,\n"
"but named parameters are generally preferred because they make the\n"
"query a little easier to read."
msgstr ""
"Hibernate unterstützt auch Stellenparameter wie in `PreparedStatement`,\n"
"aber benannte Parameter werden gewöhnlich bevorzugt, weil die Abfrage\n"
"damit ein bisschen leichter zu lesen ist."

#: s/java.md.tt2:76
msgid ""
"See the\n"
"[Hibernate Manual](http://docs.jboss.org/hibernate/stable/core/reference/en/"
"html/objectstate.html#objectstate-querying-executing-parameters)\n"
"for more information on named parameters."
msgstr ""
"Siehe das [Handbuch zu Hibernate](http://docs.jboss.org/hibernate/stable/"
"core/reference/en/html/objectstate.html#objectstate-querying-executing-"
"parameters) zu weitere Informationen über benannte Parameter."

#: s/java.md.tt2:80
msgid ""
"MyBatis\n"
"-------"
msgstr ""
"MyBatis\n"
"-------"

#: s/java.md.tt2:83
msgid ""
"[MyBatis](http://www.mybatis.org/) is a database framework that\n"
"hides a lot of the JDBC code from the developer, allowing him or\n"
"her to focus on writing SQL.  The SQL statements are typically\n"
"stored in XML files."
msgstr ""
"[MyBatis](http://www.mybatis.org/) ist ein Datenbankframework,\n"
"das viel von dem JDBC-Code vor dem Entwickler versteckt, so dass er\n"
"oder sie sich darauf konzentrieren kann, SQL zu schreiben. Die\n"
"SQL-Anweisungen werden typischerweise in XML-Dateien gespeichert."

#: s/java.md.tt2:88
msgid ""
"MyBatis automatically creates `PreparedStatement`s behind the scenes.\n"
"Nothing extra needs to be done by the programmer."
msgstr ""
"MyBatis erstellt automatisch `PreparedStatement` hinter den Kulissen.\n"
"Der Programmierer braucht nichts weiter zu machen."

#: s/java.md.tt2:91
msgid ""
"To give you some context, here's an example showing how a basic\n"
"query is called with MyBatis.  The input data is passed into the\n"
"`PeopleMapper` instance and then it gets inserted into the\n"
"\"selectPeopleByNameAndAge\" query."
msgstr ""
"Um etwas Kontext zu herzustellen, so sieht ein Beispiel aus\n"
"wie eine einfache Abfrage mit MyBatis aufgerufen wird. Die\n"
"Eingabedaten werden der Instanz `PeopleMapper` übergeben und\n"
"dann in die Abfrage \"selectPeopleByNameAndAge\" eingefügt."

#: s/java.md.tt2:96
msgid ""
"XML mapping document\n"
"===================="
msgstr ""
"XML-Zuordnungsdatei\n"
"==================="

#: s/java.md.tt2:99
msgid ""
"    <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n"
"    <!DOCTYPE mapper\n"
"    PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n"
"    \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n"
"    <mapper namespace=\"com.bobbytables.mybatis.PeopleMapper\">\n"
"    <select id=\"selectPeopleByNameAndAge\" resultType=\"list\">\n"
"        <!-- lastName and age are automatically sanitized --->\n"
"        SELECT * FROM people WHERE lastName = #{lastName} AND age > #{age}\n"
"    </select>\n"
"    </mapper>"
msgstr ""
"    <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n"
"    <!DOCTYPE mapper\n"
"    PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n"
"    \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n"
"    <mapper namespace=\"com.bobbytables.mybatis.PeopleMapper\">\n"
"    <select id=\"selectPeopleByNameAndAge\" resultType=\"list\">\n"
"        <!-- lastName und age werden automatisch bereinigt --->\n"
"        SELECT * FROM people WHERE lastName = #{lastName} AND age > #{age}\n"
"    </select>\n"
"    </mapper>"

#: s/java.md.tt2:110
msgid ""
"Mapper class\n"
"============"
msgstr ""
"Zuordnungsklasse\n"
"================"

#: s/java.md.tt2:113
msgid ""
"    public interface PeopleMapper {\n"
"        List<Person> selectPeopleByNameAndAge(@Param(\"lastName\") String "
"name, @Param(\"age\") int age);\n"
"    }"
msgstr ""
"    public interface PeopleMapper {\n"
"        List<Person> selectPeopleByNameAndAge(@Param(\"lastName\") String "
"name, @Param(\"age\") int age);\n"
"    }"

#: s/java.md.tt2:117
msgid ""
"Invoking the query\n"
"=================="
msgstr ""
"Aufruf der Abfrage\n"
"=================="

#: s/java.md.tt2:120
msgid ""
"    String name = //user input\n"
"    int age = //user input\n"
"    SqlSessionFactory sqlMapper = //...\n"
"    SqlSession session = sqlMapper.openSession();\n"
"    try {\n"
"        PeopleMapper mapper = session.getMapper(PeopleMapper.class);\n"
"        List<Person> people = mapper.selectPeopleByNameAndAge(name, age); //"
"data is automatically sanitized\n"
"        for (Person person : people) {\n"
"            //...\n"
"        }\n"
"    } finally {\n"
"        session.close();\n"
"    }\n"
msgstr ""
"    String name = //Benutzereingabe\n"
"    int age = //Benutzereingabe\n"
"    SqlSessionFactory sqlMapper = //...\n"
"    SqlSession session = sqlMapper.openSession();\n"
"    try {\n"
"        PeopleMapper mapper = session.getMapper(PeopleMapper.class);\n"
"        List<Person> people = mapper.selectPeopleByNameAndAge(name, age); //"
"data is automatically sanitized\n"
"        for (Person person : people) {\n"
"            //...\n"
"        }\n"
"    } finally {\n"
"        session.close();\n"
"    }\n"

#: s/perl.md.tt2:1
msgid ""
"Perl\n"
"===="
msgstr ""
"Perl\n"
"===="

#: s/perl.md.tt2:4
msgid ""
"Perl's [DBI](http://search.cpan.org/dist/DBI), available on the [CPAN]"
"(http://search.cpan.org), supports parameterized SQL calls.  Both the `do` "
"method and `prepare` method support parameters (\"placeholders\", as they "
"call them) for most database drivers. For example:"
msgstr ""
"Die Perl-Datenbankschnittstelle [DBI](http://search.cpan.org/dist/DBI), "
"erhältlich vom [CPAN](http://search.cpan.org), beherrscht parameterisierte "
"SQL-Aufrufe. Die Methoden `do` und `prepare` unterstützen Parameter (dort: "
"\"Platzhalter\") für die meisten Datenbanktreiber. Zum Beispiel:"

#: s/perl.md.tt2:6
msgid ""
"\n"
"    $sth = $dbh->prepare(\"SELECT * FROM users WHERE email = ?\");\n"
"    foreach my $email (@emails) {\n"
"        $sth->execute($email);\n"
"        $row = $sth->fetchrow_hashref;\n"
"        [...]\n"
"    }"
msgstr ""
"\n"
"    $sth = $dbh->prepare(\"SELECT * FROM users WHERE email = ?\");\n"
"    foreach my $email (@emails) {\n"
"        $sth->execute($email);\n"
"        $row = $sth->fetchrow_hashref;\n"
"        [...]\n"
"    }"

#: s/perl.md.tt2:14
msgid ""
"However, you can't use parameterization for identifiers (table\n"
"names, column names) so you need to use DBI's `quote_identifier()`\n"
"method for that:"
msgstr ""
"Man kann aber Parameterisierung nicht für Benenner (Tabellennamen, "
"Spaltennamen) verwenden, also muss man die Methode `quote_identifier()` aus "
"DBI verwenden:"

#: s/perl.md.tt2:18
msgid ""
"    # Make sure a table name we want to use is safe:\n"
"    my $quoted_table_name = $dbh->quote_identifier($table_name);"
msgstr ""
"    # Dafür sorgen, dass der zu verwendende Tabellenname sicher ist:\n"
"    my $quoted_table_name = $dbh->quote_identifier($table_name);"

#: s/perl.md.tt2:21
msgid ""
"    # Assume @cols contains a list of column names you need to fetch:\n"
"    my $cols = join ',', map { $dbh->quote_identifier($_) } @cols;"
msgstr ""
"    # Unter der Annahme, dass @cols eine Liste der zu holenden Spaltennamen "
"enthält:\n"
"    my $cols = join ',', map { $dbh->quote_identifier($_) } @cols;"

#: s/perl.md.tt2:24
msgid ""
"    my $sth = $dbh->prepare(\"SELECT $cols FROM $quoted_table_name ...\");"
msgstr ""
"    my $sth = $dbh->prepare(\"SELECT $cols FROM $quoted_table_name ...\");"

#: s/perl.md.tt2:26
msgid ""
"You could also avoid writing SQL by hand by using [DBIx::Class](http://p3rl."
"org/DBIx::Class), [SQL::Abstract](http://p3rl.org/SQL::Abstract) etc to "
"generate your SQL for you programmatically."
msgstr ""
"Man kann auch vermeiden, SQL manuell zu schreiben, indem man [DBIx::Class]"
"(http://p3rl.org/DBIx::Class), [SQL::Abstract](http://p3rl.org/SQL::"
"Abstract) usw. verwendet, um SQL programmatisch zu erzeugen."

#: s/perl.md.tt2:28
msgid ""
"What is Taint mode?\n"
"-------------------"
msgstr ""
"Was ist der Taint-Modus?\n"
"------------------------"

#: s/perl.md.tt2:31
msgid ""
"Taint mode is a special set of security checks that Perl performs on data "
"input into your program from external sources. The input data is marked as  "
"tainted (untrusted) and may not be used in commands that would allow you to "
"shoot yourself in the foot. See [the perlsec manpage](http://perldoc.perl."
"org/perlsec.html) for a detailed breakdown of what taint mode tracks."
msgstr ""
"Der Taintmodus stellt besondere Sicherheitsprüfungen dar, die Perl an "
"Eingabedaten durchführt, welche aus externen Quellen stammen. Die "
"Eingabedaten werden als \"unrein\" (nicht vertrauenswürdig) markiert und "
"können nicht in Befehlen verwendet werden, mit denen man sich ins eigene "
"Fleisch schneiden würde. Siehe [perlsec](http://perldoc.perl.org/perlsec."
"html) für eine detaillierte Übersicht, was der Taintmodus überwacht."

#: s/perl.md.tt2:33
msgid "To invoke taint mode:"
msgstr "Um den Taintmodus anzuschalten:"

#: s/perl.md.tt2:35
msgid ""
"    # From the command line\n"
"    perl -T program.pl"
msgstr ""
"    # Auf der Kommandozeile\n"
"    perl -T program.pl"

#: s/perl.md.tt2:38
msgid ""
"    # At the top of your script\n"
"    #!/usr/bin/perl -T"
msgstr ""
"    # Am Anfang des Skripts\n"
"    #!/usr/bin/perl -T"

#: s/perl.md.tt2:41
msgid ""
"When your script trips one of the taint checks your application will issue a "
"fatal error message. For testing purposes `-t` will issue warnings instead "
"of fatal errors. `-t` is not a substitute for `-T`."
msgstr ""
"Wenn eine Taintprüfung im Skript fehlschlägt, gibt die Anwendung eine fatale "
"Fehlermeldung aus. Für Testzwecke gibt `-t` Warnungen statt fataler Fehler "
"aus. `-t` ist kein Ersatz für `-T`."

#: s/perl.md.tt2:46
msgid "Explain how DBI supports taint mode, both inbound and outbound.\n"
msgstr ""
"Erklärung zum Taintmodus von Perl und wie DBI den Taintmodus sowohl einwärts "
"als auch ausgehend unterstützt.\n"

#: s/php.md.tt2:1
msgid ""
"PHP\n"
"==="
msgstr ""
"PHP\n"
"==="

#: s/php.md.tt2:4
msgid ""
"PHP is a little more disorganized than how\n"
"[Perl handles parameters](./perl.html).\n"
"The standard [MySQL extension](http://php.net/manual/en/book.mysql.php)\n"
"doesn't support parameterization, although the\n"
"[PostgreSQL extension](http://www.php.net/manual/en/book.pgsql.php) does:"
msgstr ""
"PHP ist ein bisschen unorganisierter im [Vergleich zu Perl](./perl.html).\n"
"Die Standarderweiterung [MySQL](http://php.net/manual/de/book.mysql.php)\n"
"beherrscht keine Parameterisierung, aber die Erweiterung\n"
"[PostgreSQL](http://www.php.net/manual/de/book.pgsql.php) schon:"

#: s/php.md.tt2:10
msgid ""
"    $result = pg_query_params( $dbh, 'SELECT * FROM users WHERE email = $1', "
"array($email) );"
msgstr ""
"    $result = pg_query_params( $dbh, 'SELECT * FROM users WHERE email = $1', "
"array($email) );"

#: s/php.md.tt2:12
msgid ""
"Note that the query must be in single-quotes or have the `$` escaped\n"
"to avoid PHP trying to parse it as a variable."
msgstr ""
"Hinweis: die Abfrage muss in einfachen Anführungszeichen stehen oder das `$` "
"muss maskiert werden, damit PHP nicht versucht, es als Variable zu "
"analysieren."

#: s/php.md.tt2:15
msgid ""
"**However**, you should probably be using an abstraction layer.\n"
"The [ODBC](http://php.net/manual/en/book.uodbc.php) and\n"
"[PDO](http://www.php.net/manual/en/book.pdo.php) extensions both\n"
"support parameterization and multiple databases:"
msgstr ""
"Es sollte jedoch wohl eine Abstraktionsschicht verwendet werden.\n"
"Die [ODBC-](http://php.net/manual/en/book.uodbc.php) und\n"
"[PDO-Erweiterungen](http://www.php.net/manual/en/book.pdo.php)\n"
"unterstützen sowohl Parameterisierung und mehrere Datenbanken:"

#: s/php.md.tt2:20
msgid ""
"Using mysqli\n"
"------------"
msgstr ""
"Mittels mysqli\n"
"--------------"

#: s/php.md.tt2:23
msgid "The MySQL Improved extension handles bound parameters."
msgstr "Die Erweiterung MySQL Improved beherrscht Parameterbindung."

#: s/php.md.tt2:25
msgid ""
"    $stmt = $db->prepare('update people set name = ? where id = ?');\n"
"    $stmt->bind_param('si',$name,$id);\n"
"    $stmt->execute();"
msgstr ""
"    $stmt = $db->prepare('update people set name = ? where id = ?');\n"
"    $stmt->bind_param('si',$name,$id);\n"
"    $stmt->execute();"

#: s/php.md.tt2:29
msgid ""
"Using ADODB\n"
"-----------"
msgstr ""
"Mittels ADODB\n"
"-------------"

#: s/php.md.tt2:32
msgid ""
"ADODB provides a way to prepare, bind and execute all in the same method "
"call."
msgstr ""
"Mit ADODB kann man in einem Methodenaufruf eine Anweisung vorbereiten, daran "
"binden und sie ausführen."

#: s/php.md.tt2:34
msgid ""
"    $dbConnection = NewADOConnection($connectionString);\n"
"    $sqlResult = $dbConnection->Execute(\n"
"        'SELECT user_id,first_name,last_name FROM users WHERE username=? AND "
"password=?',\n"
"        array($_REQUEST['username'], sha1($_REQUEST['password'])\n"
"    );"
msgstr ""
"    $dbConnection = NewADOConnection($connectionString);\n"
"    $sqlResult = $dbConnection->Execute(\n"
"        'SELECT user_id,first_name,last_name FROM users WHERE username=? AND "
"password=?',\n"
"        array($_REQUEST['username'], sha1($_REQUEST['password'])\n"
"    );"

#: s/php.md.tt2:40
msgid ""
"Using the ODBC layer\n"
"--------------------"
msgstr ""
"Mittels ODBC\n"
"------------"

#: s/php.md.tt2:43
msgid ""
"    $stmt = odbc_prepare( $conn, 'SELECT * FROM users WHERE email = ?' );\n"
"    $success = odbc_execute( $stmt, array($email) );"
msgstr ""
"    $stmt = odbc_prepare( $conn, 'SELECT * FROM users WHERE email = ?' );\n"
"    $success = odbc_execute( $stmt, array($email) );"

#: s/php.md.tt2:46
msgid "Or:"
msgstr "Oder:"

#: s/php.md.tt2:48
msgid ""
"    $res = odbc_exec($conn, 'SELECT * FROM users WHERE email = ?', array"
"($email));\n"
"    $sth = $dbh->prepare('SELECT * FROM users WHERE email = :email');\n"
"    $sth->execute(array(':email' => $email));"
msgstr ""
"    $res = odbc_exec($conn, 'SELECT * FROM users WHERE email = ?', array"
"($email));\n"
"    $sth = $dbh->prepare('SELECT * FROM users WHERE email = :email');\n"
"    $sth->execute(array(':email' => $email));"

#: s/php.md.tt2:52
msgid ""
"Using the PDO layer\n"
"-------------------"
msgstr ""
"Mittels PDO\n"
"-----------"

#: s/php.md.tt2:55
msgid "Here's the long way to do bind parameters."
msgstr "So bindet man Parameter auf die ausführliche Weise."

#: s/php.md.tt2:57
msgid ""
"    $dbh = new PDO('mysql:dbname=testdb;host=127.0.0.1', $user, $password);\n"
"    $stmt = $dbh->prepare('INSERT INTO REGISTRY (name, value) VALUES (:"
"name, :value)');\n"
"    $stmt->bindParam(':name', $name);\n"
"    $stmt->bindParam(':value', $value);"
msgstr ""
"    $dbh = new PDO('mysql:dbname=testdb;host=127.0.0.1', $user, $password);\n"
"    $stmt = $dbh->prepare('INSERT INTO REGISTRY (name, value) VALUES (:"
"name, :value)');\n"
"    $stmt->bindParam(':name', $name);\n"
"    $stmt->bindParam(':value', $value);"

#: s/php.md.tt2:62
msgid ""
"    // insert one row\n"
"    $name = 'one';\n"
"    $value = 1;\n"
"    $stmt->execute();"
msgstr ""
"    // eine Zeile einfügen\n"
"    $name = 'one';\n"
"    $value = 1;\n"
"    $stmt->execute();"

#: s/php.md.tt2:67
msgid "And a shorter way to pass things in."
msgstr "Und auf eine kürzere Weise, sie zu übergeben."

#: s/php.md.tt2:69
msgid ""
"    $dbh = new PDO('mysql:dbname=testdb;host=127.0.0.1', $user, $password);\n"
"    $stmt = $dbh->prepare('UPDATE people SET name = :new_name WHERE id = :"
"id');\n"
"    $stmt->execute( array('new_name' => $name, 'id' => $id) );\n"
msgstr ""
"    $dbh = new PDO('mysql:dbname=testdb;host=127.0.0.1', $user, $password);\n"
"    $stmt = $dbh->prepare('UPDATE people SET name = :new_name WHERE id = :"
"id');\n"
"    $stmt->execute( array('new_name' => $name, 'id' => $id) );\n"

#: s/plsql.md.tt2:1
msgid ""
"PL/SQL\n"
"======"
msgstr ""
"PL/SQL\n"
"======"

#: s/plsql.md.tt2:4
msgid "Examples assume the following table structure:"
msgstr "Beispiele setzen folgende Tabellenstruktur voraus:"

#: s/plsql.md.tt2:6
msgid ""
"    CREATE TABLE users (\n"
"        username VARCHAR2(8) UNIQUE,\n"
"        accessed_at DATE,\n"
"        superuser NUMBER(1,0)\n"
"    );"
msgstr ""
"    CREATE TABLE users (\n"
"        username VARCHAR2(8) UNIQUE,\n"
"        accessed_at DATE,\n"
"        superuser NUMBER(1,0)\n"
"    );"

#: s/plsql.md.tt2:12
msgid ""
"    INSERT INTO users VALUES ('janihur',  sysdate,      0);\n"
"    INSERT INTO users VALUES ('petdance', sysdate - 12, 1);\n"
"    INSERT INTO users VALUES ('albundy',  sysdate - 3,  0);\n"
"    INSERT INTO users VALUES ('donduck',  sysdate - 18, 0);"
msgstr ""
"    INSERT INTO users VALUES ('janihur',  sysdate,      0);\n"
"    INSERT INTO users VALUES ('petdance', sysdate - 12, 1);\n"
"    INSERT INTO users VALUES ('albundy',  sysdate - 3,  0);\n"
"    INSERT INTO users VALUES ('donduck',  sysdate - 18, 0);"

#: s/plsql.md.tt2:17
msgid ""
"Always prefer static SQL when possible\n"
"--------------------------------------"
msgstr ""
"Wenn möglich, immer statisches SQL bevorzugen\n"
"---------------------------------------------"

#: s/plsql.md.tt2:20
msgid "Static SQL leaves no room for SQL injection."
msgstr "Statisches SQL kann keine SQL-Einschleusung verursachen."

#: s/plsql.md.tt2:22
msgid ""
"    CREATE OR REPLACE FUNCTION user_access (\n"
"        p_uname IN VARCHAR2\n"
"    ) RETURN date AS\n"
"        v_accessed_at date;\n"
"    BEGIN\n"
"        SELECT accessed_at INTO v_accessed_at FROM users WHERE username = "
"p_uname;\n"
"        RETURN v_accessed_at;\n"
"    END;\n"
"    /"
msgstr ""
"    CREATE OR REPLACE FUNCTION user_access (\n"
"        p_uname IN VARCHAR2\n"
"    ) RETURN date AS\n"
"        v_accessed_at date;\n"
"    BEGIN\n"
"        SELECT accessed_at INTO v_accessed_at FROM users WHERE username = "
"p_uname;\n"
"        RETURN v_accessed_at;\n"
"    END;\n"
"    /"

#: s/plsql.md.tt2:32 s/plsql.md.tt2:64 s/plsql.md.tt2:94
msgid ""
"\n"
"    SELECT user_access('janihur')\n"
"      AS \"JANIHUR LAST SEEN\" FROM DUAL;"
msgstr ""
"\n"
"    SELECT user_access('janihur')\n"
"      AS \"JANIHUR LAST SEEN\" FROM DUAL;"

#: s/plsql.md.tt2:36 s/plsql.md.tt2:68 s/plsql.md.tt2:98
msgid ""
"    JANIHUR LAST SEEN\n"
"    -------------------\n"
"    2011-08-03 17:11:24"
msgstr ""
"    JANIHUR LAST SEEN\n"
"    -------------------\n"
"    2011-08-03 17:11:24"

#: s/plsql.md.tt2:40 s/plsql.md.tt2:72 s/plsql.md.tt2:102
msgid ""
"    SELECT user_access('whocares'' or superuser = 1 or username = "
"''whocares') \n"
"      AS \"SUPERUSER LAST SEEN\" FROM DUAL;"
msgstr ""
"    SELECT user_access('whocares'' or superuser = 1 or username = "
"''whocares') \n"
"      AS \"SUPERUSER LAST SEEN\" FROM DUAL;"

#: s/plsql.md.tt2:43 s/plsql.md.tt2:105
msgid ""
"    SUPERUSER LAST SEEN\n"
"    -------------------"
msgstr ""
"    SUPERUSER LAST SEEN\n"
"    -------------------"

#: s/plsql.md.tt2:46
msgid ""
"\n"
"If you need dynamic SQL avoid string concatenation when possible\n"
"----------------------------------------------------------------"
msgstr ""
"\n"
"Wenn dynamisches SQL benötigt wird, soll wenn möglich Stringverknüpfung "
"vermieden werden\n"
"------------------------------------------------------------------------------"
"----------"

#: s/plsql.md.tt2:50
msgid "String concatenation opens doors to possible SQL injection exploits:"
msgstr "Durch Stringverknüpfung kann es zu SQL-Einschleusung kommen:"

#: s/plsql.md.tt2:52
msgid ""
"    CREATE OR REPLACE FUNCTION user_access (\n"
"        p_uname IN VARCHAR2\n"
"    ) RETURN date AS\n"
"        v_accessed_at date;\n"
"        v_query constant varchar2(32767) := \n"
"          'SELECT accessed_at FROM users WHERE username = ''' || p_uname || "
"'''';\n"
"    BEGIN\n"
"        EXECUTE IMMEDIATE v_query INTO v_accessed_at;\n"
"        RETURN v_accessed_at;\n"
"    END;\n"
"    /"
msgstr ""
"    CREATE OR REPLACE FUNCTION user_access (\n"
"        p_uname IN VARCHAR2\n"
"    ) RETURN date AS\n"
"        v_accessed_at date;\n"
"        v_query constant varchar2(32767) := \n"
"          'SELECT accessed_at FROM users WHERE username = ''' || p_uname || "
"'''';\n"
"    BEGIN\n"
"        EXECUTE IMMEDIATE v_query INTO v_accessed_at;\n"
"        RETURN v_accessed_at;\n"
"    END;\n"
"    /"

#: s/plsql.md.tt2:75
msgid ""
"    SUPERUSER LAST SEEN\n"
"    -------------------\n"
"    2011-07-22 17:11:24"
msgstr ""
"    SUPERUSER LAST SEEN\n"
"    -------------------\n"
"    2011-07-22 17:11:24"

#: s/plsql.md.tt2:79
msgid "Instead use bind variables:"
msgstr "Man benutzt stattdessen Bindevariablen:"

#: s/plsql.md.tt2:81
msgid ""
"\n"
"    CREATE OR REPLACE FUNCTION user_access (\n"
"        p_uname IN VARCHAR2\n"
"    ) RETURN date AS\n"
"        v_accessed_at date;\n"
"        v_query constant varchar2(32767) := \n"
"          'SELECT accessed_at FROM users WHERE username = :a';\n"
"    BEGIN\n"
"        EXECUTE IMMEDIATE v_query INTO v_accessed_at USING p_uname;\n"
"        RETURN v_accessed_at;\n"
"    END;\n"
"    /"
msgstr ""
"\n"
"    CREATE OR REPLACE FUNCTION user_access (\n"
"        p_uname IN VARCHAR2\n"
"    ) RETURN date AS\n"
"        v_accessed_at date;\n"
"        v_query constant varchar2(32767) := \n"
"          'SELECT accessed_at FROM users WHERE username = :a';\n"
"    BEGIN\n"
"        EXECUTE IMMEDIATE v_query INTO v_accessed_at USING p_uname;\n"
"        RETURN v_accessed_at;\n"
"    END;\n"
"    /"

#: s/plsql.md.tt2:108
msgid ""
"Implicit Data Type Conversion Injection\n"
"---------------------------------------"
msgstr ""
"Einschleusung durch implizite Datentypumwandlung\n"
"------------------------------------------------"

#: s/plsql.md.tt2:111
msgid ""
"Also NLS session parameters (`NLS_DATE_FORMAT`, `NLS_TIMESTAMP_FORMAT`, "
"`NLS_TIMESTAMP_TZ_FORMAT`, `NLS_NUMERIC_CHARACTER`) can be used to modify or "
"inject SQL statements."
msgstr ""
"Auch die NLS-Sitzungsparameter (`NLS_DATE_FORMAT`, `NLS_TIMESTAMP_FORMAT`, "
"`NLS_TIMESTAMP_TZ_FORMAT`, `NLS_NUMERIC_CHARACTER`) können benutzt werden, "
"um SQL-Abfragen zu verändern oder in sie einzuschleusen."

#: s/plsql.md.tt2:113
msgid ""
"In next example data type conversion takes place when `p_since` is "
"implicitly converted to a string for concatenation. Note how the value of "
"`NLS_DATE_FORMAT` affects to the query string in `users_since()` function!"
msgstr ""
"Im nächsten Beispiel findet Datentypumwandlung statt, wenn `p_since` "
"implizit in einen String für die Verknüpfung umgewandelt wird. Achtung: der "
"Wert von `NLS_DATE_FORMAT` beeinflusst den Abfragestring in der Funktion "
"`users_since()`!"

#: s/plsql.md.tt2:115 s/plsql.md.tt2:163
msgid "    ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS';"
msgstr "    ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS';"

#: s/plsql.md.tt2:117 s/plsql.md.tt2:165
msgid ""
"    CREATE OR REPLACE TYPE userlist_t AS TABLE OF VARCHAR2(8);\n"
"    /"
msgstr ""
"    CREATE OR REPLACE TYPE userlist_t AS TABLE OF VARCHAR2(8);\n"
"    /"

#: s/plsql.md.tt2:120
msgid ""
"    CREATE OR REPLACE FUNCTION users_since(\n"
"        p_since IN DATE\n"
"    ) RETURN userlist_t PIPELINED AS\n"
"        v_users userlist_t;\n"
"        v_query constant varchar2(32767) := \n"
"          'SELECT username FROM users WHERE superuser = 0 and accessed_at > "
"''' || p_since || ''' order by accessed_at desc';\n"
"    BEGIN\n"
"        DBMS_OUTPUT.PUT_LINE('v_query = ' || v_query);\n"
"        EXECUTE IMMEDIATE v_query BULK COLLECT INTO v_users;"
msgstr ""
"    CREATE OR REPLACE FUNCTION users_since(\n"
"        p_since IN DATE\n"
"    ) RETURN userlist_t PIPELINED AS\n"
"        v_users userlist_t;\n"
"        v_query constant varchar2(32767) := \n"
"          'SELECT username FROM users WHERE superuser = 0 and accessed_at > "
"''' || p_since || ''' order by accessed_at desc';\n"
"    BEGIN\n"
"        DBMS_OUTPUT.PUT_LINE('v_query = ' || v_query);\n"
"        EXECUTE IMMEDIATE v_query BULK COLLECT INTO v_users;"

#: s/plsql.md.tt2:130 s/plsql.md.tt2:178
msgid ""
"        FOR i IN v_users.FIRST .. v_users.LAST LOOP\n"
"          PIPE ROW(v_users(i));\n"
"        END LOOP;"
msgstr ""
"        FOR i IN v_users.FIRST .. v_users.LAST LOOP\n"
"          PIPE ROW(v_users(i));\n"
"        END LOOP;"

#: s/plsql.md.tt2:134 s/plsql.md.tt2:182
msgid ""
"        RETURN;\n"
"    END;\n"
"    /"
msgstr ""
"        RETURN;\n"
"    END;\n"
"    /"

#: s/plsql.md.tt2:138
msgid ""
"\n"
"    ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD\"SUPRISE!\"';\n"
"    SELECT COLUMN_VALUE AS \"REGULARS\" FROM TABLE(users_since(sysdate - "
"30));"
msgstr ""
"\n"
"    ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD\"SUPRISE!\"';\n"
"    SELECT COLUMN_VALUE AS \"REGULARS\" FROM TABLE(users_since(sysdate - "
"30));"

#: s/plsql.md.tt2:142
msgid ""
"    v_query = SELECT username FROM users WHERE superuser = 0 and accessed_at "
">\n"
"    '2011-07-04SUPRISE!' order by accessed_at desc"
msgstr ""
"    v_query = SELECT username FROM users WHERE superuser = 0 and accessed_at "
">\n"
"    '2011-07-04SUPRISE!' order by accessed_at desc"

#: s/plsql.md.tt2:145
msgid ""
"    REGULARS\n"
"    --------\n"
"    janihur\n"
"    albundy\n"
"    donduck"
msgstr ""
"    REGULARS\n"
"    --------\n"
"    janihur\n"
"    albundy\n"
"    donduck"

#: s/plsql.md.tt2:151
msgid ""
"    ALTER SESSION SET NLS_DATE_FORMAT = '\"'' or superuser = 1 or username = "
"''whocares\"';\n"
"    SELECT COLUMN_VALUE AS \"SUPERUSER IS\" FROM TABLE(users_since(sysdate - "
"30));"
msgstr ""
"    ALTER SESSION SET NLS_DATE_FORMAT = '\"'' or superuser = 1 or username = "
"''whocares\"';\n"
"    SELECT COLUMN_VALUE AS \"SUPERUSER IS\" FROM TABLE(users_since(sysdate - "
"30));"

#: s/plsql.md.tt2:154
msgid ""
"    v_query = SELECT username FROM users WHERE superuser = 0 and accessed_at "
"> ''\n"
"    or superuser = 1 or username = 'whocares' order by accessed_at desc"
msgstr ""
"    v_query = SELECT username FROM users WHERE superuser = 0 and accessed_at "
"> ''\n"
"    or superuser = 1 or username = 'whocares' order by accessed_at desc"

#: s/plsql.md.tt2:157
msgid ""
"    SUPERUSE\n"
"    --------\n"
"    petdance"
msgstr ""
"    SUPERUSE\n"
"    --------\n"
"    petdance"

#: s/plsql.md.tt2:161
msgid ""
"The remedy is to set the format modifier explicitly: `to_char(p_since, 'YYYY-"
"MM-DD')`."
msgstr ""
"Abhilfe schafft, den Formatwandler explizit anzugeben: `to_char(p_since, "
"'YYYY-MM-DD')`."

#: s/plsql.md.tt2:168
msgid ""
"    CREATE OR REPLACE FUNCTION users_since(\n"
"        p_since IN DATE\n"
"    ) RETURN userlist_t PIPELINED AS\n"
"        v_users userlist_t;\n"
"        v_query constant varchar2(32767) := \n"
"          'SELECT username FROM users WHERE superuser = 0 and accessed_at > "
"''' || to_char(p_since, 'YYYY-MM-DD') || ''' order by accessed_at desc';\n"
"    BEGIN\n"
"        DBMS_OUTPUT.PUT_LINE('v_query = ' || v_query);\n"
"        EXECUTE IMMEDIATE v_query BULK COLLECT INTO v_users;"
msgstr ""
"    CREATE OR REPLACE FUNCTION users_since(\n"
"        p_since IN DATE\n"
"    ) RETURN userlist_t PIPELINED AS\n"
"        v_users userlist_t;\n"
"        v_query constant varchar2(32767) := \n"
"          'SELECT username FROM users WHERE superuser = 0 and accessed_at > "
"''' || p_since || ''' order by accessed_at desc';\n"
"    BEGIN\n"
"        DBMS_OUTPUT.PUT_LINE('v_query = ' || v_query);\n"
"        EXECUTE IMMEDIATE v_query BULK COLLECT INTO v_users;"

#: s/plsql.md.tt2:186
msgid ""
"Now the value of NLS parameter `NLS_DATE_FORMAT` is ignored during the query."
msgstr ""
"Jetzt wird der Wert des NLS-Parameters `NLS_DATE_FORMAT` während der Abfrage "
"nicht mehr beachtet."

#: s/plsql.md.tt2:188
msgid ""
"    ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD\"SUPRISE!\"';\n"
"    SELECT COLUMN_VALUE AS \"REGULARS\" FROM TABLE(users_since(sysdate - "
"30));"
msgstr ""
"    ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD\"SUPRISE!\"';\n"
"    SELECT COLUMN_VALUE AS \"REGULARS\" FROM TABLE(users_since(sysdate - "
"30));"

#: s/plsql.md.tt2:191
msgid ""
"    v_query = SELECT username FROM users WHERE superuser = 0 and accessed_at "
">\n"
"    '2011-07-04' order by accessed_at desc"
msgstr ""
"    v_query = SELECT username FROM users WHERE superuser = 0 and accessed_at "
">\n"
"    '2011-07-04' order by accessed_at desc"

#: s/plsql.md.tt2:194
msgid ""
"    REGULARS\n"
"    --------\n"
"    janihur\n"
"    albundy\n"
"    donduck\n"
msgstr ""
"    REGULARS\n"
"    --------\n"
"    janihur\n"
"    albundy\n"
"    donduck\n"

#: s/postgresql.md.tt2:1
msgid ""
"PostgreSQL\n"
"=========="
msgstr ""
"PostgreSQL\n"
"=========="

#: s/postgresql.md.tt2:4
msgid ""
"All of PostgreSQL's [procedural languages](http://www.postgresql.org/docs/"
"current/static/xplang.html), which allow you to write functions and "
"procedures inside the database, allow you to execute arbitrary SQL "
"statements."
msgstr ""
"Alle [prozeduralen Sprachen von PostgreSQL](http://www.postgresql.org/docs/"
"current/static/xplang.html), mit denen man Funktionen und Prozeduren "
"innerhalb der Datenbank schreiben kann, haben die Fähigkeit, beliebige SQL-"
"Anweisungen auszuführen."

#: s/postgresql.md.tt2:6
msgid ""
"PL/pgSQL\n"
"--------"
msgstr ""
"PL/pgSQL\n"
"--------"

#: s/postgresql.md.tt2:9
msgid ""
"The safest way to execute SQL inside a PL/pgSQL statement is just to do so:"
msgstr ""
"Die sicherste Weise, SQL innerhalb einer PL/pgSQL-Anweisung auszuführen:"

#: s/postgresql.md.tt2:11
msgid ""
"    CREATE OR REPLACE FUNCTION user_access (\n"
"        p_uname TEXT\n"
"    ) RETURNS timestamp language plpgsql AS $$\n"
"    BEGIN\n"
"        RETURN accessed_at FROM users WHERE username = p_uname;\n"
"    END;\n"
"    $$;"
msgstr ""
"    CREATE OR REPLACE FUNCTION user_access (\n"
"        p_uname TEXT\n"
"    ) RETURNS timestamp language plpgsql AS $$\n"
"    BEGIN\n"
"        RETURN accessed_at FROM users WHERE username = p_uname;\n"
"    END;\n"
"    $$;"

#: s/postgresql.md.tt2:19
msgid ""
"For such a simple case, you're actually better off writing a pure SQL "
"function:"
msgstr ""
"In so einem einfachen Fall schreibt man besser eine reine SQL-Funktion:"

#: s/postgresql.md.tt2:21
msgid ""
"    CREATE OR REPLACE FUNCTION user_access (\n"
"        p_uname TEXT\n"
"    ) RETURNS timestamp language sql AS $$\n"
"        SELECT accessed_at FROM users WHERE username = $1;\n"
"    $$;"
msgstr ""
"    CREATE OR REPLACE FUNCTION user_access (\n"
"        p_uname TEXT\n"
"    ) RETURNS timestamp language sql AS $$\n"
"        SELECT accessed_at FROM users WHERE username = $1;\n"
"    $$;"

#: s/postgresql.md.tt2:27
msgid ""
"But sometimes you have to do more complicated things. Perhaps you "
"dynamically add `WHERE` clause expressions based on input. In such cases, "
"you'll end up using PL/pgSQL's `EXECUTE` syntax. Here's an example with an "
"SQL injection vulnerability:"
msgstr ""
"Aber manchmal möchte man kompliziertere Sachen machen wie z.B. `WHERE`-"
"Teilausdrücke dynamisch je nach Eingabedaten hinzuzufügen. In diesem Fall "
"benutzt man die `EXECUTE`-Syntax von PL/pgSQL. Ein Beispiel mit einer "
"Gefährdung durch SQL-Einschleusung:"

#: s/postgresql.md.tt2:29
msgid ""
"    CREATE OR REPLACE FUNCTION get_users(\n"
"        p_column TEXT,\n"
"        p_value  TEXT\n"
"    ) RETURNS SETOF users LANGUAGE plpgsql AS $$\n"
"    DECLARE\n"
"        query TEXT := 'SELECT * FROM users';\n"
"    BEGIN\n"
"        IF p_column IS NOT NULL THEN\n"
"            query := query || ' WHERE ' || p_column\n"
"                  || $_$ = '$_$ || p_value || $_$'$_$;\n"
"        END IF;\n"
"        RETURN QUERY EXECUTE query;\n"
"    END;\n"
"    $$;"
msgstr ""
"    CREATE OR REPLACE FUNCTION get_users(\n"
"        p_column TEXT,\n"
"        p_value  TEXT\n"
"    ) RETURNS SETOF users LANGUAGE plpgsql AS $$\n"
"    DECLARE\n"
"        query TEXT := 'SELECT * FROM users';\n"
"    BEGIN\n"
"        IF p_column IS NOT NULL THEN\n"
"            query := query || ' WHERE ' || p_column\n"
"                  || $_$ = '$_$ || p_value || $_$'$_$;\n"
"        END IF;\n"
"        RETURN QUERY EXECUTE query;\n"
"    END;\n"
"    $$;"

#: s/postgresql.md.tt2:44
msgid ""
"Both the `p_column` and the `p_value` arguments are vulnerable. The way to "
"avoid this problem is to use the `quote_ident()` function to quote an SQL "
"identifier (`p_column` in this case) and `quote_lteral()` to quote a literal "
"value:"
msgstr ""
"Die Argumente `p_column` und `p_value` sind beide angreifbar. Um das Problem "
"zu vermeiden, wird die Funktion `quote_ident()` verwendet, um einen SQL-"
"Bezeichner (hier: `p_column`) zu maskieren und `quote_literal()`, um einen "
"Literalwert zu maskieren:"

#: s/postgresql.md.tt2:46
msgid ""
"    CREATE OR REPLACE FUNCTION get_users(\n"
"        p_column TEXT,\n"
"        p_value  TEXT\n"
"    ) RETURNS SETOF users LANGUAGE plpgsql AS $$\n"
"    DECLARE\n"
"        query TEXT := 'SELECT * FROM users';\n"
"    BEGIN\n"
"        IF p_column IS NOT NULL THEN\n"
"            query := query || ' WHERE ' || quote_ident(p_column)\n"
"                  || ' = ' || quote_literal(p_value);\n"
"        END IF;\n"
"        RETURN QUERY EXECUTE query;\n"
"    END;\n"
"    $$;"
msgstr ""
"    CREATE OR REPLACE FUNCTION get_users(\n"
"        p_column TEXT,\n"
"        p_value  TEXT\n"
"    ) RETURNS SETOF users LANGUAGE plpgsql AS $$\n"
"    DECLARE\n"
"        query TEXT := 'SELECT * FROM users';\n"
"    BEGIN\n"
"        IF p_column IS NOT NULL THEN\n"
"            query := query || ' WHERE ' || quote_ident(p_column)\n"
"                  || ' = ' || quote_literal(p_value);\n"
"        END IF;\n"
"        RETURN QUERY EXECUTE query;\n"
"    END;\n"
"    $$;"

#: s/postgresql.md.tt2:61
msgid "It's quite a bit easier to read, too!"
msgstr "So ist es auch viel leichter zu lesen!"

#: s/postgresql.md.tt2:63
msgid ""
"PL/Perl\n"
"-------"
msgstr ""
"PL/Perl\n"
"-------"

#: s/postgresql.md.tt2:66 s/postgresql.md.tt2:71
msgid "TODO."
msgstr "In Vorbereitung."

#: s/postgresql.md.tt2:68
msgid ""
"PL/Python\n"
"---------"
msgstr ""
"PL/Python\n"
"---------"

#: s/postgresql.md.tt2:73
msgid "### PL/Tcl"
msgstr "### PL/Tcl"

#: s/postgresql.md.tt2:75
msgid "TODO.\n"
msgstr "In Vorbereitung.\n"

#: s/python.md.tt2:1
msgid ""
"Python\n"
"======"
msgstr ""
"Python\n"
"======"

#: s/python.md.tt2:4
msgid ""
"Using the [Python DB API](http://wiki.python.org/moin/DatabaseProgramming/), "
"don't do this:"
msgstr ""
"Unter Verwendung der [Python-DB-API](http://wiki.python.org/moin/"
"DatabaseProgramming/) ist das folgende falsch:"

#: s/python.md.tt2:6
msgid ""
"    # Do NOT do it this way.\n"
"    cmd = \"update people set name='%s' where id='%s'\" % (name, id)\n"
"    curs.execute(cmd)"
msgstr ""
"    # Dieses Beispiel ist FALSCH.\n"
"    cmd = \"update people set name='%s' where id='%s'\" % (name, id)\n"
"    curs.execute(cmd)"

#: s/python.md.tt2:10
msgid "Instead, do this:"
msgstr "Stattdessen korrekt:"

#: s/python.md.tt2:12
msgid "    curs.execute('update people set name=:1 where id=:2', [name, id])"
msgstr "    curs.execute('update people set name=:1 where id=:2', [name, id])"

#: s/python.md.tt2:17 s/ruby.md.tt2:18 s/scheme.md.tt2:18
msgid "-   Add some narrative.\n"
msgstr "-   Mehr Erläuterung.\n"

#: s/ruby.md.tt2:1
msgid ""
"Ruby\n"
"===="
msgstr ""
"Ruby\n"
"===="

#: s/ruby.md.tt2:4
msgid ""
"In Ruby on Rails using [ActiveRecord](http://guides.rubyonrails.org/"
"active_record_querying.html):"
msgstr ""
"In Ruby on Rails mit [ActiveRecord](http://guides.rubyonrails.org/"
"active_record_querying.html):"

#: s/ruby.md.tt2:6
msgid "    Person.find :all, :conditions => ['id = ? or name = ?', id, name]"
msgstr "    Person.find :all, :conditions => ['id = ? or name = ?', id, name]"

#: s/ruby.md.tt2:8
msgid "or"
msgstr "oder"

#: s/ruby.md.tt2:10
msgid "    Person.find_by_sql ['SELECT * from persons WHERE name = ?', name]"
msgstr "    Person.find_by_sql ['SELECT * from persons WHERE name = ?', name]"

#: s/ruby.md.tt2:12
msgid ""
"\n"
"Using [Ruby/DBI](http://ruby-dbi.rubyforge.org/): analog to [Perl](./perl."
"html)."
msgstr ""
"\n"
"[Ruby/DBI](http://ruby-dbi.rubyforge.org/) ist analog zu [Perl](./perl.html)."

#: s/scheme.md.tt2:1
msgid ""
"Scheme\n"
"======"
msgstr ""
"Scheme\n"
"======"

#: s/scheme.md.tt2:4
msgid ""
"CHICKEN Scheme\n"
"--------------"
msgstr ""
"CHICKEN-Scheme\n"
"--------------"

#: s/scheme.md.tt2:7
msgid ""
"[CHICKEN](http://www.call-with-current-continuation.org/) is a compiler for "
"[Scheme](http://schemers.org/)"
msgstr ""
"[CHICKEN](http://www.call-with-current-continuation.org/) ist ein Compiler "
"für [Scheme](http://schemers.org/)"

#: s/scheme.md.tt2:9
msgid ""
"\n"
"    (define DB (sqlite3:open  \"myexample.db\"))\n"
"    (sqlite3:exec DB \"INSERT INTO Person(name) VALUES(?)\" \"Luke Skywalker"
"\")\n"
"    (sqlite3:for-each-row print DB \"SELECT id,name FROM Person WHERE id=?\" "
"3)\n"
"    (define adults (sqlite3:map-row DB \"SELECT name FROM Person WHERE age "
">= ?\" 18))"
msgstr ""
"\n"
"    (define DB (sqlite3:open  \"myexample.db\"))\n"
"    (sqlite3:exec DB \"INSERT INTO Person(name) VALUES(?)\" \"Luke Skywalker"
"\")\n"
"    (sqlite3:for-each-row print DB \"SELECT id,name FROM Person WHERE id=?\" "
"3)\n"
"    (define adults (sqlite3:map-row DB \"SELECT name FROM Person WHERE age "
">= ?\" 18))"

#: s/translations.md.tt2:1
msgid "# Translations"
msgstr "# Übersetzungen"

#: s/translations.md.tt2:3
msgid "The following natural languages are supported on bobby-tables.com:"
msgstr ""
"Die folgenden natürlichen Sprachen werden auf bobby-tables.com unterstützt:"

#: s/translations.md.tt2:5
msgid ""
"* [English](http://bobby-tables.com/) (native)\n"
"* [German](http://bobby-tables.com/de_DE/) (fairly current)\n"
"* [Russian](http://bobby-tables.com/ru_RU/) (just starting)"
msgstr ""
"* [englisch](http://bobby-tables.com/) (ursprünglich)\n"
"* [deutsch](http://bobby-tables.com/de_DE/) (ziemlich aktuell)\n"
"* [russisch](http://bobby-tables.com/ru_RU/) (erst am Anfang)"

#: s/translations.md.tt2:9
msgid ""
"We'd love to have translations into other languages as well.  Please\n"
"contact the\n"
"[bobby-tables mailing list](https://groups.google.com/forum/#!forum/bobby-"
"tables)\n"
"and ask a team member about how you can help."
msgstr ""
"Wir würden gerne auch Übersetzungen für andere Sprachen haben. Bitte schreibe "
"an die [bobby-tables-Mailingliste](https://groups.google."
"com/forum/#!forum/bobby-"
"tables) und frage einen Teilnehmer, wie du helfen kannst."

#: s/translations.md.tt2:14
msgid "# Contributing translations"
msgstr "# an Übersetzungen mitwirken"

#: s/translations.md.tt2:16
msgid "1. Run `make messages`."
msgstr "1. Führe `make messages` aus."

#: s/translations.md.tt2:18
msgid ""
"2. Skip this step if you just amend a translation. If you need to start a "
"new\n"
"language, copy `share/locale/com.bobby-tables.pot` to\n"
"`share/locale/xx_YY/LC_MESSAGES/com.bobby-tables.po`, but substitute `xx` "
"for\n"
"the appropriate\n"
"[language code](http://en.wikipedia.org/wiki/List_of_ISO_639-1_codes)\n"
"and `YY` for the\n"
"[territory code](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2).\n"
"(Alternatively to copying, use the command `msginit`.) Naming convention\n"
"examples:"
msgstr ""
"2. Überspringe diesen Schritt, wenn du nur eine Übersetzung verbesserst. "
"Falls du eine neue Sprache anfängst, kopiere "
"`share/locale/com.bobby-tables.pot` nach"
"`share/locale/xx_YY/LC_MESSAGES/com.bobby-tables.po`, aber ersetze `xx` "
"mit dem entsprechenden [Sprachcode](http://en.wikipedia."
"org/wiki/List_of_ISO_639-1_codes) "
"und `YY` mit dem [Territorialcode](http://en.wikipedia."
"org/wiki/ISO_3166-1_alpha-2). "
"(Alternativ zum Kopieren benutze den Befehl `msginit`.) Beispiele für die "
"Namenskonvention:"

#: s/translations.md.tt2:28
msgid ""
"        sv_SE.po    standard Swedish\n"
"        pt_BR.po    Brazilian Portuguese"
msgstr ""
"        sv_SE.po    Standardschwedisch\n"
"        pt_BR.po    brasilianisches Portugiesisch"

#: s/translations.md.tt2:31
msgid ""
"3. Edit the PO file. [Lokalize (formerly KBabel)](http://l10n.kde.org/"
"tools/)\n"
"is excellent, [Poedit](http://www.poedit.net/) is good. Any text editor\n"
"supporting UTF-8 can handle PO files, but it will not be as convenient."
msgstr ""
"3. Bearbeite die PO-Datei. "
"[Lokalize (vormals KBabel)](http://l10n.kde.org/tools/) ist ausgezeichnet, "
"[Poedit](http://www.poedit.net/) ist gut. Jeder Texteditor, der UTF-8 "
"unterstützt, kann mit PO-Dateien umgehen, aber es ist nicht so bequem."

#: s/translations.md.tt2:35
msgid "4. Run the normal `make` step."
msgstr "4. Führe den normalen `make`-Schritt aus."

#: s/translations.md.tt2:37
msgid "# Guidelines for translations"
msgstr "# Leitfaden für Übersetzungen"

#: s/translations.md.tt2:39
msgid ""
"* Become familiar with the source mark-up language \"Markdown\" used for\n"
" producing the rendered HTML. The backtick (\\`) is an important piece\n"
" of syntax pertaining to translation, it indicates code, e.g. a\n"
" variable name, and code is not translated, i.e. copy the source text\n"
" into the target language as-is. Indented paragraphs are also code.\n"
" Translate only comments in such code blocks."
msgstr ""
"* Mache dich mit der Auszeichnungssprache \"Markdown\" vertraut, aus welcher "
"HTML produziert wird. Der Gravis (\\`) ist ein für Übersetzungen wichtiger "
"Teil der Syntax; er kennzeichnet Code, z.B. einen Variablennamen. Code wird "
"nicht übersetzt, d.h. der Ursprungstext wird unverändert in die Zielsprache "
"übernommen. Eingerückte Absätze stellen auch Code dar. Übersetze in solchen "
"Codeblöcken nur die Kommentare."

#: s/translations.md.tt2:46
msgid ""
"* To find out where a piece of English is from to see the context,\n"
"run `ack -a 'source text goes here'`. Most of the source text is\n"
"in directory `s/`. Run `make clean` first to avoid duplicates in\n"
"build files. (If you don't have [ack](http://betterthangrep.com)\n"
"you can use `grep -R`."
msgstr ""
"* Um herauszufinden, woher ein englischer Text stammt, um den Kontext zu "
"sehen, "
"führe `ack -a 'source text goes here'` aus. Der überwiegende Teil des "
"Ursprungstextes befindet sich im Verzeichnis `s/`. Führe zunächst `make "
"clean` "
"aus, um Duplikate in den Build-Dateien zu vermeiden. (Wenn du "
"[ack](http://betterthangrep.com) nicht hast, kannst du `grep -R` verwenden."

#: s/translations.md.tt2:52
msgid "* You can check your progress by running `make l10n-status`."
msgstr "* Du kannst deinen Fortschritt mittels `make l10n-status` beobachten."

#: s/translations.md.tt2:54
msgid "Apart from that, the normal rules for any translation apply:"
msgstr "Außerdem gelten die normalen Richtlinien für jedwede Übersetzungen:"

#: s/translations.md.tt2:56
msgid ""
"* Don't translate literally or word-by-word, instead capture the\n"
"essence of each sentence/paragraph and reformulate it so it reads\n"
"naturally. If you have to merge or rearrange sentence parts, do it."
msgstr ""
"* Übersetze nicht wortwörtlich, sondern drücke das Wesentliche eines "
"Satzes/Absatzes aus und formuliere es so, dass es sich natürlich liest. "
"Scheue "
"nicht davor zurück, dafür Satzteile zu verbinden oder umzubauen."

#: s/translations.md.tt2:60
msgid ""
"* Avoid keeping key words/technical jargon in English, consult the\n"
"standard literature for existing translations of key words. (Software\n"
"vendors such as Microsoft and KDE publish shared translation tables,\n"
"import those into your PO editor, too.) In case you find no good\n"
"translation, use your imagination and put yourself into the position\n"
"of a member of your potential audience: is the sentence still\n"
"understandable? If not, add a parenthetical remark to the key word."
msgstr ""
"* Vermeide es, verständnistragende Wörter/technische Fachwörter unübersetzt "
"zu "
"lassen. Ziehe die Standardliteratur für existierende Übersetzungen zu Rate. "
"(Softwarehersteller wie Microsoft oder KDE veröffentlichen "
"Übersetzungstabellen, importiere sie auch in den PO-Editor.) Wenn du keine "
"gute "
"Übersetzung findest, stelle dir vor, du wärst in der Stelle deiner "
"Zielgruppe: "
"ist der Satz noch verständlich? Falls nicht, füge eine Erläuterung in "
"Klammern "
"hinzu."

#: s/translations.md.tt2:68
msgid ""
"* It can happen that source text is wrong in some way (typos, factual\n"
"errors). This should be improved first in a separate patch, independent\n"
"from your translation. Fix it yourself, and if not possible (e.g.\n"
"because the English text is ambiguous), use `git annotate` to find\n"
"out who wrote it and ask for clarification.\n"
msgstr ""
"* Es kommt vor, dass der Ursprungstext falsch ist (Tipp- oder Sachfehler). "
"Das "
"sollte zunächst in einem gesonderten Patch unabhängig von deiner Übersetzung "
"verbessert werden. Korrigiere es selbst, und falls das nicht geht (z.B. weil "
"der englische Text mehrdeutig ist), benutze `git annotate`, um "
"herauszufinden, "
"wer das geschrieben hat und bitte um Klarstellung."

#: tt/footer.tt:5
msgid ""
"This site's content is available under the <a href=\"https://creativecommons."
"org/licenses/by-sa/3.0/\">Creative Commons Attribution-ShareAlike 3.0 "
"License</a>"
msgstr ""
"Die Inhalte dieser Website stehen unter der <a href=\"http://creativecommons."
"org/licenses/by-sa/3.0/\">Creative-Commons-Lizenz mit Namensnennung und "
"Weitergabe unter gleichen Bedingungen, Version 3.0</a>."

#: tt/footer.tt:8
msgid "Fork me on GitHub"
msgstr "Mach auf GitHub mit"

#: tt/header.tt:6
msgid "Bobby Tables: A guide to preventing SQL injection"
msgstr "Bobby Tables: Ein Leitfaden gegen SQL-Einschleusung"

#. (currlang)
#: tt/page.tt:6
msgid "bobby-tables.com: A guide to preventing SQL injection in {currlang}"
msgstr "bobby-tables.com: Ein Leitfaden gegen SQL-Einschleusung in {currlang}"

#: tt/page.tt:8
msgid "bobby-tables.com: A guide to preventing SQL injection"
msgstr "bobby-tables.com: Ein Leitfaden gegen SQL-Einschleusung"
