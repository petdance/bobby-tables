# This site's content is available under the Creative Commons Attribution-ShareAlike 3.0 License.
# Mariano Valles <zucaritas@gmail.com>, 2013.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: YEAR-MO-DA HO:MI+ZONE\n"
"PO-Revision-Date: 2013-06-02 18:45+0100\n"
"Last-Translator: Mariano Valles\n"
"Language-Team: Spanish <Spanish>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 1.5.5\n"

#: crank.pl:31
msgid "Home"
msgstr "Inicio"

#: crank.pl:32
msgid "Translations"
msgstr "Traducciones"

#: crank.pl:33
msgid "About"
msgstr "Acerca"

#: s/about.md.tt2:1
msgid "# About Bobby Tables and SQL injection"
msgstr "# Acerca de Bobby Tables e inyecciónes via SQL"

#: s/about.md.tt2:3
msgid "# Why did Bobby's school lose their records?"
msgstr "# ¿Por qué la escuela de Bobby perdió los registros"

#: s/about.md.tt2:5
msgid ""
"The school apparently stores the names of their students in a table called "
"Students. When a new student arrives, the school inserts his/her name into "
"this table. The code doing the insertion might look as follows:"
msgstr ""
"La escuela aparentemente almacena los nombres de sus estudiantes en una "
"tabla llamada Students. Cuando un estudiante llega, la escuela inserta su "
"nombre en esta tabla. El código encargado de la inserción puede tener esta "
"forma:"

#: s/about.md.tt2:7
msgid ""
"    $sql = \"INSERT INTO Students (Name) VALUES ('\" . $studentName . \"');"
"\";\n"
"    execute_sql($sql);"
msgstr ""
"    $sql = \"INSERT INTO Students (Name) VALUES ('\" . $studentName . \"');"
"\";\n"
"    execute_sql($sql);"

#: s/about.md.tt2:10
msgid ""
"The first line creates a string containing an SQL INSERT statement. The "
"content of the `$studentName` variable is glued into the SQL statement. The "
"second line sends the resulting SQL statement to the database. The pitfall "
"of this code is that outside data, in this case the content of `"
"$studentName`, becomes part of the SQL statement."
msgstr ""
"La primera linea crea una cadena conteniendo la sentencia INSERT de SQL. El "
"contenido de la variable `$studentName` es adherida a la sentencia SQL. La "
"segunda linea envía la sentencia SQL resultante a la base de datos. The "
"pitfall of this code is that outside data, in this case the content of `"
"$studentName`, becomes part of the SQL statement. La trampa de este código "
"es que los datos externos, en este caso, el contenido de `$studentName`, se "
"hace parte de la sentencia SQL."

#: s/about.md.tt2:12
msgid ""
"First let's see what the SQL statement looks like if we insert a student "
"named John:"
msgstr ""
"Primero observemos como se ve una sentencia SQL si queremos insertar el "
"nombre de un estudiante 'John':"

#: s/about.md.tt2:14
msgid "    INSERT INTO Students (Name) VALUES ('John');"
msgstr "    INSERT INTO Students (Name) VALUES ('John');"

#: s/about.md.tt2:16
msgid ""
"This does exactly what we want: it inserts John into the Students table."
msgstr ""
"Esto hace exactamente lo que queremos: inserta John a la tabla Students."

#: s/about.md.tt2:18
msgid ""
"Now we insert little Bobby Tables, by setting `$studentName` to `Robert'); "
"DROP TABLE Students;--`. The SQL statement becomes:"
msgstr ""
"Ahora insertamos al pequeño Bobby Tables, al asignar `Robert'); DROP TABLE "
"Students;--` a `$studentName`. La sentencia SQL se convierte en: "

#: s/about.md.tt2:20
msgid ""
"    INSERT INTO Students (Name) VALUES ('Robert'); DROP TABLE Students;--');"
msgstr ""
"    INSERT INTO Students (Name) VALUES ('Robert'); DROP TABLE Students;--');"

#: s/about.md.tt2:22
msgid ""
"This inserts Robert into the Students table. However, the INSERT statement "
"is now followed by a DROP TABLE statement which removes the entire Students "
"table. Ouch!"
msgstr ""
"Esto inserta Robert en la tabla Students. Sin embargo, la sentencia INSERT "
"tiene ahora una setencia DROP TABLE anexada que elimina la tabla Students "
"por completo."

#: s/about.md.tt2:24
msgid ""
"\n"
"# How to avoid Bobby Tables"
msgstr ""
"\n"
"# Como evitas 'Bobby Tables'"

#: s/about.md.tt2:27
msgid "There is only one way to avoid Bobby Tables attacks"
msgstr "Hay sólo una manera de evitar los ataques de tipo Bobby Tables"

#: s/about.md.tt2:29
msgid ""
"* Do not create SQL statements that include outside data.\n"
"* Use parameterized SQL calls."
msgstr ""
"* No crear sentencias SQL que incluyan datos del exterior\n"
"* Usar llamadas SQL parametrizadas."

#: s/about.md.tt2:32
msgid ""
"That's it. Don't try to escape invalid characters. Don't try to do it "
"yourself. Learn how to use parameterized statements. Always, every single "
"time."
msgstr ""
"Eso es todo. No trates de escapar caracteres inválidos. No trates de hacerlo "
"tu mismo. Aprende a usar sentencias parametrizadas. Siempre, en cada ocasión."

#: s/about.md.tt2:34
msgid ""
"The strip gets one thing crucially wrong. The answer is not to \"sanitize "
"your database inputs\" yourself. It is prone to error.\n"
msgstr ""
"La tira tiene un error crucial. La respuesta no es \"sanitizar tus ingresos "
"a bases de datos\" tu mismo. Es susceptible a error.\n"

#: s/asp.md.tt2:1
msgid ""
"ASP\n"
"==="
msgstr ""
"ASP\n"
"==="

#: s/asp.md.tt2:4
msgid "Older ASP uses positional placeholders."
msgstr "Versiones anteriores de ASP usan marcadores de posición."

#: s/asp.md.tt2:6
msgid ""
"    objCmd.CommandType = adCmdText;\n"
"    objCmd.CommandText = \"UPDATE members SET photo = ? WHERE memberID = ?"
"\";\n"
"    objCmd.Parameters.Append(objCmd.CreateParameter(\"filename\", adVarChar, "
"adParamInput, 510, fileName));\n"
"    objCmd.Parameters.Append(objCmd.CreateParameter(\"memberID\", adInteger, "
"adParamInput, 4, memberid ));\n"
"    objCmd.Execute(adExecuteNoRecords);"
msgstr ""
"    objCmd.CommandType = adCmdText;\n"
"    objCmd.CommandText = \"UPDATE members SET photo = ? WHERE memberID = ?"
"\";\n"
"    objCmd.Parameters.Append(objCmd.CreateParameter(\"filename\", adVarChar, "
"adParamInput, 510, fileName));\n"
"    objCmd.Parameters.Append(objCmd.CreateParameter(\"memberID\", adInteger, "
"adParamInput, 4, memberid ));\n"
"    objCmd.Execute(adExecuteNoRecords);"

#: s/asp.md.tt2:12
msgid ""
"\n"
"Newer ASP (ASP.Net?) can handle named placeholders."
msgstr ""
"\n"
"Nuevos ASP (ASP.Net?)  pueden manejar placeholders con nombres."

#: s/asp.md.tt2:15
msgid ""
"    objCmd.CommandType = adCmdText;\n"
"    objCmd.CommandText = \"UPDATE members SET photo = @filename WHERE "
"memberID = @memberID\";\n"
"    objCmd.Parameters.Append(objCmd.CreateParameter(\"@memberID\", "
"adInteger, adParamInput, 4, memberid ));\n"
"    objCmd.Parameters.Append(objCmd.CreateParameter(\"@filename\", "
"adVarChar, adParamInput, 510, fileName));\n"
"    objCmd.Execute(adExecuteNoRecords);\n"
"    gblDelobjParams(objCmd);"
msgstr ""
"    objCmd.CommandType = adCmdText;\n"
"    objCmd.CommandText = \"UPDATE members SET photo = @filename WHERE "
"memberID = @memberID\";\n"
"    objCmd.Parameters.Append(objCmd.CreateParameter(\"@memberID\", "
"adInteger, adParamInput, 4, memberid ));\n"
"    objCmd.Parameters.Append(objCmd.CreateParameter(\"@filename\", "
"adVarChar, adParamInput, 510, fileName));\n"
"    objCmd.Execute(adExecuteNoRecords);\n"
"    gblDelobjParams(objCmd);"

#: s/asp.md.tt2:22 s/dotnet.md.tt2:13 s/perl.md.tt2:43 s/ruby.md.tt2:15
#: s/scheme.md.tt2:15
msgid ""
"To do\n"
"-----"
msgstr ""
"Por hacer\n"
"----------"

#: s/asp.md.tt2:25
msgid "Add some narrative\n"
msgstr "Añadir un poco de narrativa\n"

#: s/coldfusion.md.tt2:1
msgid ""
"ColdFusion\n"
"=========="
msgstr ""
"ColdFusion\n"
"=========="

#: s/coldfusion.md.tt2:4
#, fuzzy
msgid ""
"In ColdFusion there is a tag called `cfqueryparam` that should be used "
"whenever writing inline queries."
msgstr ""
"En ColdFusion existe un identificador('tag') llamado `cfqueryparam`que debe "
"ser usado siempre que se escriban consultas en linea (inline)"

#: s/coldfusion.md.tt2:6
msgid ""
"    <cfquery name=\"queryTest\">\n"
"    SELECT FirstName, LastName, Phone\n"
"    FROM   tblUser\n"
"    WHERE  Status =\n"
"      <cfqueryparam cfsqltype=\"CF_SQL_VARCHAR\" value=\"#form.status#\">\n"
"    </cfquery>"
msgstr ""
"    <cfquery name=\"queryTest\">\n"
"    SELECT FirstName, LastName, Phone\n"
"    FROM   tblUser\n"
"    WHERE  Status =\n"
"      <cfqueryparam cfsqltype=\"CF_SQL_VARCHAR\" value=\"#form.status#\">\n"
"    </cfquery>"

#: s/coldfusion.md.tt2:13
msgid ""
"\n"
"Stored procedures can be invoked with the `cfstoredproc` and `cfprocparam` "
"tags."
msgstr ""
"\n"
"Procesos almacenados pueden ser invocados con los tags `cfstoredproc` y "
"`cfprocparam`."

#: s/coldfusion.md.tt2:16
msgid ""
"Recent versions of ColdFusion provide a set of functions to run queries "
"that\n"
"have a slightly different syntax, but still provide parameterized queries."
msgstr ""
"Versiones recientes de ColdFusion proveen un set de funciones para ejecutar "
"consultas\n"
"que tengan una sintáxis "

#: s/coldfusion.md.tt2:19
msgid ""
"\n"
"    <cfscript>\n"
"      var myQuery = new Query(sql=\"\n"
"        SELECT FirstName, LastName, Phone\n"
"        FROM   tblUser\n"
"        WHERE  Status = :status\n"
"      \");\n"
"      myQuery.addParam(\n"
"        name      = \"status\",\n"
"        value     = form.status,\n"
"        cfsqltype = \"cf_sql_varchar\"\n"
"      );\n"
"      var rawQuery = myQuery.execute().getResult();\n"
"    </cfscript>"
msgstr ""
"\n"
"    <cfscript>\n"
"      var myQuery = new Query(sql=\"\n"
"        SELECT FirstName, LastName, Phone\n"
"        FROM   tblUser\n"
"        WHERE  Status = :status\n"
"      \");\n"
"      myQuery.addParam(\n"
"        name      = \"status\",\n"
"        value     = form.status,\n"
"        cfsqltype = \"cf_sql_varchar\"\n"
"      );\n"
"      var rawQuery = myQuery.execute().getResult();\n"
"    </cfscript>"

#: s/csharp.md.tt2:1
msgid ""
"C\\#\n"
"==="
msgstr ""
"C\\#\n"
"==="

#: s/csharp.md.tt2:4
msgid ""
"From the [C# Online](http://en.csharp-online.net/) wiki page [ASP.NET "
"Security Hacks--Avoiding SQL Injection](http://en.csharp-online.net/ASP."
"NET_Security_Hacks%E2%80%94Avoiding_SQL_Injection)"
msgstr ""
"De la wiki [ASP.NET Security Hacks--Avoiding SQL Injection](http://en.csharp-"
"online.net/ASP.NET_Security_Hacks%E2%80%94Avoiding_SQL_Injection) de [C# "
"Online](http://en.csharp-online.net/) "

#: s/csharp.md.tt2:6
msgid ""
"\n"
"    SqlCommand userInfoQuery = new SqlCommand(\n"
"        \"SELECT id, name, email FROM users WHERE id = @UserName\",\n"
"        someSqlConnection);"
msgstr ""
"\n"
"    SqlCommand userInfoQuery = new SqlCommand(\n"
"        \"SELECT id, name, email FROM users WHERE id = @UserName\",\n"
"        someSqlConnection);"

#: s/csharp.md.tt2:11
msgid ""
"    SqlParameter userNameParam = userInfoQuery.Parameters.Add(\"@UserName"
"\",\n"
"        SqlDbType.VarChar, 25 /* max length of field */ );"
msgstr ""
"    SqlParameter userNameParam = userInfoQuery.Parameters.Add(\"@UserName"
"\",\n"
"        SqlDbType.VarChar, 25 /* max length of field */ );"

#: s/csharp.md.tt2:14
msgid ""
"    // userName is some string valued user input variable\n"
"    userNameParam.Value = userName;"
msgstr ""
"    // userName es una variable de entrada del usuario con valor cadena de "
"caracteres\n"
"    userNameParam.Value = userName;"

#: s/csharp.md.tt2:17
msgid "Or simpler:"
msgstr "O más simple:"

#: s/csharp.md.tt2:19
msgid ""
"\n"
"    String username = \"joe.bloggs\";\n"
"    SqlCommand sqlQuery = new SqlCommand(\"SELECT user_id, first_name,"
"last_name FROM users WHERE username = ?username\",  sqlConnection);\n"
"    sqlQuery.Parameters.AddWithValue(\"?username\", username);\n"
msgstr ""
"\n"
"    String username = \"joe.bloggs\";\n"
"    SqlCommand sqlQuery = new SqlCommand(\"SELECT user_id, first_name,"
"last_name FROM users WHERE username = ?username\",  sqlConnection);\n"
"    sqlQuery.Parameters.AddWithValue(\"?username\", username);\n"

#: s/delphi.md.tt2:1
msgid ""
"Delphi\n"
"======"
msgstr ""
"Delphi\n"
"======"

#: s/delphi.md.tt2:4
msgid "To use a prepared statement, do something like this:"
msgstr "Para usar una sentencia preparada, haz algo como esto:"

#: s/delphi.md.tt2:6
msgid ""
"    query.SQL.Text := 'update people set name=:Name where id=:ID';\n"
"    query.Prepare;\n"
"    query.ParamByName( 'Name' ).AsString := name;\n"
"    query.ParamByName( 'ID' ).AsInteger := id;\n"
"    query.ExecSQL;\n"
msgstr ""
"    query.SQL.Text := 'update people set name=:Name where id=:ID';\n"
"    query.Prepare;\n"
"    query.ParamByName( 'Name' ).AsString := name;\n"
"    query.ParamByName( 'ID' ).AsInteger := id;\n"
"    query.ExecSQL;\n"

#: s/dotnet.md.tt2:1
msgid ""
".NET\n"
"===="
msgstr ""
".NET\n"
"===="

#: s/dotnet.md.tt2:4
msgid "Reference:"
msgstr "Referencia:"

#: s/dotnet.md.tt2:6
msgid ""
"-    [SqlCommand.Prepare](http://msdn.microsoft.com/en-us/library/system."
"data.sqlclient.sqlcommand.prepare.aspx) in the .NET Framework Class Library"
msgstr ""
"-    [SqlCommand.Prepare](http://msdn.microsoft.com/en-us/library/system."
"data.sqlclient.sqlcommand.prepare.aspx) en la Librería de clases de .NET"

#: s/dotnet.md.tt2:8
msgid "Articles:"
msgstr "Artículos:"

#: s/dotnet.md.tt2:10
msgid ""
"-   [SQL injection](http://msdn.microsoft.com/en-us/library/ms161953.aspx) "
"on MSDN\n"
"-   [SQL Injection and how to avoid it](http://blogs.msdn.com/tom/"
"archive/2008/05/29/sql-injection-and-how-to-avoid-it.aspx) on the ASP.NET "
"Debugging blog"
msgstr ""
"-   [SQL injection](http://msdn.microsoft.com/en-us/library/ms161953.aspx) "
"en MSDN\n"
"-   [SQL Injection and how to avoid it](http://blogs.msdn.com/tom/"
"archive/2008/05/29/sql-injection-and-how-to-avoid-it.aspx) en el blog de "
"Debugging de ASP.NET"

#: s/dotnet.md.tt2:16
msgid ""
"-   Add some narrative\n"
"-   Show code examples\n"
msgstr ""
"-   Añadir más narrativa\n"
"-   Mostrar ejemplos de código\n"

#: s/index.md.tt2:1
msgid ""
"Who is Bobby Tables?\n"
"===================="
msgstr ""
"¿Quién es Bobby Tables?\n"
"===================="

#: s/index.md.tt2:4
msgid "[From the webcomic _xkcd_](http://xkcd.com/327/)"
msgstr "[Del webcomic _xkcd_](http://xkcd.com/327/)"

#: s/index.md.tt2:6
msgid ""
"<a href=\"http://xkcd.com/327/\"><img src=\"/img/xkcd.png\" alt=\"xkcd Bobby "
"Tables Cartoon\" height=\"205\" width=\"666\" /></a>"
msgstr ""
"<a href=\"http://xkcd.com/327/\"><img src=\"/img/xkcd.png\" alt=\"Caricatura "
"de Bobby Tables de xkcd\" height=\"205\" width=\"666\" /></a>"

#: s/index.md.tt2:8
msgid "<br clear=\"right\">"
msgstr "<br clear=\"right\">"

#: s/index.md.tt2:10
msgid ""
"**School**: Hi, this is your son's school. We're having some computer "
"trouble."
msgstr ""
"**Escuela**: Hola, esta es la escuela de su hijo que le llama. Estamos "
"teniendo algunos problemas de computación."

#: s/index.md.tt2:12
msgid "**Mom**: Oh, dear -- Did he break something?"
msgstr "**Mom**: Oh, dios -- Ha roto algo?"

#: s/index.md.tt2:14
msgid ""
"**School**: In a way. Did you really name your son `Robert'); DROP TABLE "
"Students;--`?"
msgstr ""
"**School**: In a way. Realmente su hijo se llama `Robert'); DROP TABLE "
"Students;--`?"

#: s/index.md.tt2:16
msgid "**Mom**: Oh. Yes. Little Bobby Tables we call him."
msgstr "**Mom**: Oh. Si. El pequeño Bobby Tables lo llamamos."

#: s/index.md.tt2:18
msgid ""
"**School**: Well, we've lost this year's student records. I hope you're "
"happy."
msgstr ""
"**School**: Bueno, hemos perdido los registros de los estudiantes de este "
"año. Espero que este contenta."

#: s/index.md.tt2:20
msgid "**Mom**: And I hope you've learned to sanitize your database inputs."
msgstr ""
"**Madre**: Y espero que hayan aprendido a sanitizar sus entradas a la base "
"de datos."

#: s/index.md.tt2:22
msgid ""
"Examples\n"
"========"
msgstr ""
"Ejemplos\n"
"========"

#: s/index.md.tt2:25
msgid "See the sidebar to the left for your specific language."
msgstr "Ver la barra a la izquierda para tu lenguaje específico."

#: s/index.md.tt2:27
msgid ""
"Other resources\n"
"==============="
msgstr ""
"Otras fuentes\n"
"==============="

#: s/index.md.tt2:30
msgid ""
"* [SQL Injection Myths and Fallacies](http://www.slideshare.net/billkarwin/"
"sql-injection-myths-and-fallacies)\n"
"* [How to Write Injection-Proof SQL](http://www.schneier.com/blog/"
"archives/2008/10/how_to_write_in.html)\n"
"* [Defending Against SQL Injection Attacks](http://download.oracle.com/oll/"
"tutorials/SQLInjection/index.htm)\n"
"* [Detecting Postgres SQL Injection](http://blog.endpoint.com/2012/06/"
"detecting-postgres-sql-injection.html)"
msgstr ""
"* [SQL Injection Myths and Fallacies](http://www.slideshare.net/billkarwin/"
"sql-injection-myths-and-fallacies)\n"
"* [How to Write Injection-Proof SQL](http://www.schneier.com/blog/"
"archives/2008/10/how_to_write_in.html)\n"
"* [Defending Against SQL Injection Attacks](http://download.oracle.com/oll/"
"tutorials/SQLInjection/index.htm)\n"
"* [Detecting Postgres SQL Injection](http://blog.endpoint.com/2012/06/"
"detecting-postgres-sql-injection.html)"

#: s/index.md.tt2:35
msgid ""
"Patches welcome\n"
"==============="
msgstr ""
"Parches son bienvenidos\n"
"==============="

#: s/index.md.tt2:38
msgid ""
"Don't see a language that you'd like to see represented? Please let me know "
"if you have updates or additions through one of these methods, in decreasing "
"order of preference."
msgstr ""
"No ves un lenguaje que querrías ver representado? Por favor, avisame si "
"tienes actualizaciones o adiciones por alguno de estos métodos, en orden "
"decreciente de preferencia."

#: s/index.md.tt2:40
msgid ""
"* Fork the [bobby-tables repository at github](http://github.com/petdance/"
"bobby-tables), make your changes, and send me a pull request.\n"
"* Add an issue in the [issue tracker](http://github.com/petdance/bobby-"
"tables/issues).\n"
"* Email me, Andy Lester, at andy at petdance.com."
msgstr ""
"* Hacer 'fork' del [repositorio de bobby-tables en github](http://github.com/"
"petdance/bobby-tables), haz tus cambios, y mandame un 'pull request'.\n"
"* Añade un problema en el [issue tracker](http://github.com/petdance/bobby-"
"tables/issues).\n"
"* Envíamen un email, Andy Lester, at andy at petdance.com."

#: s/index.md.tt2:44
msgid ""
"Translations also welcome\n"
"========================="
msgstr ""
"Las traducciones son bienvenidas\n"
"========================="

#: s/index.md.tt2:47
msgid ""
"Help translate this site! There are less than 200 phrases. No programming "
"necessary."
msgstr ""
"Ayuda a traducir este sitio! Hay menos de 200 frases. No es necesario "
"programar."

#: s/index.md.tt2:49
msgid ""
"See the instructions at the [bobby-tables repository at github](http://"
"github.com/petdance/bobby-tables#readme)."
msgstr ""
"Ver las instrucciones en [el repositorio de bobby-tables en github](http://"
"github.com/petdance/bobby-tables#readme)."

#: s/index.md.tt2:51
msgid ""
"To do\n"
"====="
msgstr ""
"Por hacer\n"
"========"

#: s/index.md.tt2:54
msgid ""
"* Explain why creating code from outside data is bad.\n"
"* Potential speed win when reusing prepared statements."
msgstr ""
"* Explicar porque crear código con datos externos es malo.\n"
"* Potencial aumento de la velocidad al usarPotential speed al usar "
"sentencias ya preparadas."

#: s/index.md.tt2:57
msgid ""
"Thanks\n"
"======"
msgstr ""
"Gracias\n"
"======"

#: s/index.md.tt2:60
msgid "Thanks to the following folks for their contributions:"
msgstr "Gracias a las siguientes personas por su contribución:"

#: s/index.md.tt2:62
#, fuzzy
msgid ""
"* [Kim Christensen](http://www.smukkekim.dk)\n"
"* Kirk Kimmel\n"
"* Nathan Mahdavi\n"
"* [Hannes Hofmann](http://www5.informatik.uni-erlangen.de/en/our-team/"
"hofmann-hannes)\n"
"* [Mike Angstadt](http://www.mangst.com)\n"
"* [Peter Ward](http://identi.ca/flowblok/)\n"
"* [David Wheeler](http://justatheory.com)\n"
"* Scott Rose\n"
"* Erik Osheim\n"
"* Russ Sivak\n"
"* [Iain Collins](http://iaincollins.com)\n"
"* Kristoffer Sall Hansen\n"
"* Jeff Emminger\n"
"* [Travis Swicegood](http://www.travisswicegood.com/)\n"
"* [Will Coleda](http://www.coleda.com/users/coke/)\n"
"* Kai Baesler\n"
"* Mike Markley\n"
"* [Michael Schwern](http://schwern.net/)\n"
"* [Jeana Clark](http://jeanaclark.org/)\n"
"* [Lars Dɪᴇᴄᴋᴏᴡ](http://search.cpan.org/~daxim/)\n"
"* [Jani Hur](http://www.jani-hur.net)\n"
"* [Sven van Haastregt](http://www.liacs.nl/home/svhaastr/)\n"
"* Andrey Chasovskikh\n"
"* Erwin Brandstetter\n"
msgstr ""
"* [Kim Christensen](http://www.smukkekim.dk)\n"
"* Kirk Kimmel\n"
"* Nathan Mahdavi\n"
"* [Hannes Hofmann](http://www5.informatik.uni-erlangen.de/en/our-team/"
"hofmann-hannes)\n"
"* [Mike Angstadt](http://www.mangst.com)\n"
"* [Peter Ward](http://identi.ca/flowblok/)\n"
"* [David Wheeler](http://justatheory.com)\n"
"* Scott Rose\n"
"* Erik Osheim\n"
"* Russ Sivak\n"
"* [Iain Collins](http://iaincollins.com)\n"
"* Kristoffer Sall Hansen\n"
"* Jeff Emminger\n"
"* [Travis Swicegood](http://www.travisswicegood.com/)\n"
"* [Will Coleda](http://www.coleda.com/users/coke/)\n"
"* Kai Baesler\n"
"* Mike Markley\n"
"* [Michael Schwern](http://schwern.net/)\n"
"* [Jeana Clark](http://jeanaclark.org/)\n"
"* [Lars DÉªá´á´á´á´á´¡](http://search.cpan.org/~daxim/)\n"
"* [Jani Hur](http://www.jani-hur.net)\n"
"* [Sven van Haastregt](http://www.liacs.nl/home/svhaastr/)\n"
"* Andrey Chasovskikh\n"
"* Erwin Brandstetter\n"

#: s/java.md.tt2:1
msgid ""
"Java\n"
"===="
msgstr ""
"Java\n"
"===="

#: s/java.md.tt2:4
msgid ""
"JDBC\n"
"----"
msgstr ""
"JDBC\n"
"----"

#: s/java.md.tt2:7
msgid ""
"The [JDBC API](http://download.oracle.com/javase/tutorial/jdbc/index.html)\n"
"has a class called\n"
"[`PreparedStatement`](http://download.oracle.com/javase/6/docs/api/java/sql/"
"PreparedStatement.html)\n"
"which allows the programmer to safely insert user-supplied data\n"
"into a SQL query.  The location of each input value in the query\n"
"string is marked with a question mark.  The various `set*()` methods\n"
"are then used to safely perform the insertion."
msgstr ""
"La [API de JDBC](http://download.oracle.com/javase/tutorial/jdbc/index."
"html)\n"
"tiene una clase llamada\n"
"[`PreparedStatement`](http://download.oracle.com/javase/6/docs/api/java/sql/"
"PreparedStatement.html)\n"
"que permite al programador insertar de modo seguro datos envíados por el "
"usuario\n"
"a una consulta SQL. La ubicación de cada valor de entrada en la cadena de "
"caracteres de consulta\n"
"es marcada con un signo de interrogación. Los variados métodos `set*()`\n"
"son usados para ejecutar la inserción de modo seguro. "

#: s/java.md.tt2:15
msgid ""
"    String name = //user input\n"
"    int age = //user input\n"
"    Connection connection = DriverManager.getConnection(...);\n"
"    PreparedStatement statement = connection.prepareStatement(\n"
"            \"SELECT * FROM people WHERE lastName = ? AND age > ?\" );\n"
"    statement.setString(1, name); //lastName is a VARCHAR\n"
"    statement.setInt(2, age); //age is an INT\n"
"    ResultSet rs = statement.executeQuery();\n"
"    while (rs.next()){\n"
"        //...\n"
"    }"
msgstr ""
"    String name = //user input\n"
"    int age = //user input\n"
"    Connection connection = DriverManager.getConnection(...);\n"
"    PreparedStatement statement = connection.prepareStatement(\n"
"            \"SELECT * FROM people WHERE lastName = ? AND age > ?\" );\n"
"    statement.setString(1, name); //lastName is a VARCHAR\n"
"    statement.setInt(2, age); //age is an INT\n"
"    ResultSet rs = statement.executeQuery();\n"
"    while (rs.next()){\n"
"        //...\n"
"    }"

#: s/java.md.tt2:27
msgid ""
"\n"
"Once a `PreparedStatement` object has been created, it can be reused\n"
"multiple times for multiple queries (for example, when using the\n"
"same query to update multiple rows in a table).  However, they are\n"
"**not thread-safe** because of the many method calls involved in\n"
"setting the parameters and executing the query.  Therefore, you\n"
"should only define `PreparedStatement` objects as method-level\n"
"variables (as opposed to class-level variables) to avoid concurrency\n"
"issues."
msgstr ""
"\n"
"Una vez que un objeto de tipo`PreparedStatement` ha sido creado,\n"
"puede ser reusado múltiples veces por multiples consultas (por ejemplo,\n"
"cuando se utiliza la misma consulta para actualizar múltiples entradas en\n"
"una tabla). Sin embargo, éstas ** no son seguras al usar hilos** debido a "
"la\n"
"gran cantidad de llamadas a métodos involucrados en establecer los "
"parámetros\n"
"y ejecutar la consulta. Por ello, se debe definir objetos "
"`PreparedStatement`\n"
"como métodos a nivel de variables (opuestos a variables a nivel de clase) "
"para\n"
"evitar problems de concurrencia."

#: s/java.md.tt2:37
msgid ""
"    List<Person>; people = //user input\n"
"    Connection connection = DriverManager.getConnection(...);\n"
"    connection.setAutoCommit(false);\n"
"    try {\n"
"        PreparedStatement statement = connection.prepareStatement(\n"
"                \"UPDATE people SET lastName = ?, age = ? WHERE id = ?\");\n"
"        for (Person person : people){\n"
"            statement.setString(1, person.getLastName());\n"
"            statement.setInt(2, person.getAge());\n"
"            statement.setInt(3, person.getId());\n"
"            statement.execute();\n"
"        }\n"
"        connection.commit();\n"
"    } catch (SQLException e) {\n"
"        connection.rollback();\n"
"    }"
msgstr ""
"    List<Person>; people = //user input\n"
"    Connection connection = DriverManager.getConnection(...);\n"
"    connection.setAutoCommit(false);\n"
"    try {\n"
"        PreparedStatement statement = connection.prepareStatement(\n"
"                \"UPDATE people SET lastName = ?, age = ? WHERE id = ?\");\n"
"        for (Person person : people){\n"
"            statement.setString(1, person.getLastName());\n"
"            statement.setInt(2, person.getAge());\n"
"            statement.setInt(3, person.getId());\n"
"            statement.execute();\n"
"        }\n"
"        connection.commit();\n"
"    } catch (SQLException e) {\n"
"        connection.rollback();\n"
"    }"

#: s/java.md.tt2:54
msgid ""
"More information on `PreparedStatement` can be found in the\n"
"[Oracle JDBC tutorial](http://download.oracle.com/javase/tutorial/jdbc/"
"basics/prepared.html)."
msgstr ""
"Más información en `PreparedStatements` puede ser encontrada en el tutorial "
"[Oracle JDBC](http://download.oracle.com/javase/tutorial/jdbc/basics/"
"prepared.html)."

#: s/java.md.tt2:57
msgid ""
"Hibernate\n"
"---------"
msgstr ""
"Hibernate\n"
"---------"

#: s/java.md.tt2:60
msgid ""
"[Hibernate](http://www.hibernate.org/) uses named parameters to\n"
"safely insert data into a query.  A named parameter consists of a\n"
"colon, followed by a unique name for the parameter."
msgstr ""
"[Hibernate](http://www.hibernate.org/) utiliza parametros con nombre\n"
"para insertar de modo seguro datos a una consulta. Un parametro con nombre\n"
"consiste en un signo de dos puntos, seguido por un nombre único para ese "
"parametro."

#: s/java.md.tt2:64
msgid ""
"    String name = //user input\n"
"    int age = //user input\n"
"    Session session = //...\n"
"    Query query = session.createQuery(\"from People where lastName = :name "
"and age > :age\");\n"
"    query.setString(\"name\", name);\n"
"    query.setInteger(\"age\", age);\n"
"    Iterator people = query.iterate();"
msgstr ""
"    String name = //user input\n"
"    int age = //user input\n"
"    Session session = //...\n"
"    Query query = session.createQuery(\"from People where lastName = :name "
"and age > :age\");\n"
"    query.setString(\"name\", name);\n"
"    query.setInteger(\"age\", age);\n"
"    Iterator people = query.iterate();"

#: s/java.md.tt2:72
msgid ""
"Hibernate also supports positional parameters like `PreparedStatement`,\n"
"but named parameters are generally preferred because they make the\n"
"query a little easier to read."
msgstr ""
"Hibernate tambien soporta parametros posicionales como `PreparedStatement`,\n"
"pero parametros con nombre son preferidos generalmente porque hacen que la "
"consulta sea\n"
"más fácil de leer."

#: s/java.md.tt2:76
msgid ""
"See the\n"
"[Hibernate Manual](http://docs.jboss.org/hibernate/stable/core/reference/en/"
"html/objectstate.html#objectstate-querying-executing-parameters)\n"
"for more information on named parameters."
msgstr ""
"Ver el \n"
"[Manual de Hibernate](http://docs.jboss.org/hibernate/stable/core/reference/"
"en/html/objectstate.html#objectstate-querying-executing-parameters)\n"
"para más informacion acerca de parámetros con nombre."

#: s/java.md.tt2:80
msgid ""
"MyBatis\n"
"-------"
msgstr ""
"MyBatis\n"
"-------"

#: s/java.md.tt2:83
msgid ""
"[MyBatis](http://www.mybatis.org/) is a database framework that\n"
"hides a lot of the JDBC code from the developer, allowing him or\n"
"her to focus on writing SQL.  The SQL statements are typically\n"
"stored in XML files."
msgstr ""
"[MyBatis](http://www.mybatis.org/) es un framework de base de datos\n"
"que esconde mucha de la logica de JBDC del desarrollador, permitiendole asi\n"
"a él/ella focalizarse en escribir SQL.  Las sentencias de SQL son "
"tipicamente\n"
"almacenadas en archivos XML."

#: s/java.md.tt2:88
msgid ""
"MyBatis automatically creates `PreparedStatement`s behind the scenes.\n"
"Nothing extra needs to be done by the programmer."
msgstr ""
"MyBatis automaticamente crea `PreparedStatements` detrás de escenas.\n"
"Nada adicional deber ser hecho por el programador."

#: s/java.md.tt2:91
msgid ""
"To give you some context, here's an example showing how a basic\n"
"query is called with MyBatis.  The input data is passed into the\n"
"`PeopleMapper` instance and then it gets inserted into the\n"
"\"selectPeopleByNameAndAge\" query."
msgstr ""
"Para darte un poco de contexto, aquí hay un ejemplo de como\n"
"una consulta basica es ejecutada con MyBatis. Los datos de ingreso\n"
"son pasados a la instancia de `PeopleMapper` y luego insertados a la "
"consulta\n"
"\"selectPeopleByNameAndAge\""

#: s/java.md.tt2:96
msgid ""
"XML mapping document\n"
"===================="
msgstr ""
"Documento de mapeo XML\n"
"===================="

#: s/java.md.tt2:99
msgid ""
"    <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n"
"    <!DOCTYPE mapper\n"
"    PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n"
"    \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n"
"    <mapper namespace=\"com.bobbytables.mybatis.PeopleMapper\">\n"
"    <select id=\"selectPeopleByNameAndAge\" resultType=\"list\">\n"
"        <!-- lastName and age are automatically sanitized --->\n"
"        SELECT * FROM people WHERE lastName = #{lastName} AND age > #{age}\n"
"    </select>\n"
"    </mapper>"
msgstr ""
"    <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n"
"    <!DOCTYPE mapper\n"
"    PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n"
"    \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n"
"    <mapper namespace=\"com.bobbytables.mybatis.PeopleMapper\">\n"
"    <select id=\"selectPeopleByNameAndAge\" resultType=\"list\">\n"
"        <!-- lastName y age son sanitizados automácticamente --->\n"
"        SELECT * FROM people WHERE lastName = #{lastName} AND age > #{age}\n"
"    </select>\n"
"    </mapper>"

#: s/java.md.tt2:110
msgid ""
"Mapper class\n"
"============"
msgstr ""
"Clase Mapper\n"
"============"

#: s/java.md.tt2:113
msgid ""
"    public interface PeopleMapper {\n"
"        List<Person> selectPeopleByNameAndAge(@Param(\"lastName\") String "
"name, @Param(\"age\") int age);\n"
"    }"
msgstr ""
"    public interface PeopleMapper {\n"
"        List<Person> selectPeopleByNameAndAge(@Param(\"lastName\") String "
"name, @Param(\"age\") int age);\n"
"    }"

#: s/java.md.tt2:117
msgid ""
"Invoking the query\n"
"=================="
msgstr ""
"Invocando la consulta\n"
"=================="

#: s/java.md.tt2:120
msgid ""
"    String name = //user input\n"
"    int age = //user input\n"
"    SqlSessionFactory sqlMapper = //...\n"
"    SqlSession session = sqlMapper.openSession();\n"
"    try {\n"
"        PeopleMapper mapper = session.getMapper(PeopleMapper.class);\n"
"        List<Person> people = mapper.selectPeopleByNameAndAge(name, age); //"
"data is automatically sanitized\n"
"        for (Person person : people) {\n"
"            //...\n"
"        }\n"
"    } finally {\n"
"        session.close();\n"
"    }\n"
msgstr ""
"    String name = //user input\n"
"    int age = //user input\n"
"    SqlSessionFactory sqlMapper = //...\n"
"    SqlSession session = sqlMapper.openSession();\n"
"    try {\n"
"        PeopleMapper mapper = session.getMapper(PeopleMapper.class);\n"
"        List<Person> people = mapper.selectPeopleByNameAndAge(name, age); //"
"data is automatically sanitized\n"
"        for (Person person : people) {\n"
"            //...\n"
"        }\n"
"    } finally {\n"
"        session.close();\n"
"    }\n"

#: s/perl.md.tt2:1
msgid ""
"Perl\n"
"===="
msgstr ""
"Perl\n"
"===="

#: s/perl.md.tt2:4
msgid ""
"Perl's [DBI](http://search.cpan.org/dist/DBI), available on the [CPAN]"
"(http://search.cpan.org), supports parameterized SQL calls.  Both the `do` "
"method and `prepare` method support parameters (\"placeholders\", as they "
"call them) for most database drivers. For example:"
msgstr ""
"[DBI](http://search.cpan.org/dist/DBI) de Perl,disponible en el [CPAN]"
"(http://search.cpan.org), soporta llamadas SQL parametrizadas.  Tanto el "
"método `do` como `prepare` soportan parámetros (\"placeholders\", como ellos "
"los llaman) para la mayortía de los drivers para bases de datos. Por ejemplo:"

#: s/perl.md.tt2:6
msgid ""
"\n"
"    $sth = $dbh->prepare(\"SELECT * FROM users WHERE email = ?\");\n"
"    foreach my $email (@emails) {\n"
"        $sth->execute($email);\n"
"        $row = $sth->fetchrow_hashref;\n"
"        [...]\n"
"    }"
msgstr ""
"\n"
"    $sth = $dbh->prepare(\"SELECT * FROM users WHERE email = ?\");\n"
"    foreach my $email (@emails) {\n"
"        $sth->execute($email);\n"
"        $row = $sth->fetchrow_hashref;\n"
"        [...]\n"
"    }"

#: s/perl.md.tt2:14
msgid ""
"However, you can't use parameterization for identifiers (table\n"
"names, column names) so you need to use DBI's `quote_identifier()`\n"
"method for that:"
msgstr ""
"Sin embargo, no puedes usar parametrizacion para identificadores\n"
"(nombres de tablas y columnas) por ello necesotas usar el método\n"
"`quote_identifier()` de DBI para ello:"

#: s/perl.md.tt2:18
msgid ""
"    # Make sure a table name we want to use is safe:\n"
"    my $quoted_table_name = $dbh->quote_identifier($table_name);"
msgstr ""
"    # Asegurate que el nombre de la tabla sea seguro:\n"
"    my $quoted_table_name = $dbh->quote_identifier($table_name);"

#: s/perl.md.tt2:21
msgid ""
"    # Assume @cols contains a list of column names you need to fetch:\n"
"    my $cols = join ',', map { $dbh->quote_identifier($_) } @cols;"
msgstr ""
"    # Asuma que @cols contiene una lista de nombres de columnas que "
"necesitamos:\n"
"    my $cols = join ',', map { $dbh->quote_identifier($_) } @cols;"

#: s/perl.md.tt2:24
msgid ""
"    my $sth = $dbh->prepare(\"SELECT $cols FROM $quoted_table_name ...\");"
msgstr ""
"    my $sth = $dbh->prepare(\"SELECT $cols FROM $quoted_table_name ...\");"

#: s/perl.md.tt2:26
msgid ""
"You could also avoid writing SQL by hand by using [DBIx::Class](http://p3rl."
"org/DBIx::Class), [SQL::Abstract](http://p3rl.org/SQL::Abstract) etc to "
"generate your SQL for you programmatically."
msgstr ""
"También puedes evitar escribir SQL a mano al usar [DBIx::Class](http://p3rl."
"org/DBIx::Class), [SQL::Abstract](http://p3rl.org/SQL::Abstract) etc para "
"que genere tu SQL por ti programáticamente."

#: s/perl.md.tt2:28
msgid ""
"What is Taint mode?\n"
"-------------------"
msgstr ""
"¿Qué es el modo Taint?\n"
"----------------------"

#: s/perl.md.tt2:31
msgid ""
"Taint mode is a special set of security checks that Perl performs on data "
"input into your program from external sources. The input data is marked as  "
"tainted (untrusted) and may not be used in commands that would allow you to "
"shoot yourself in the foot. See [the perlsec manpage](http://perldoc.perl."
"org/perlsec.html) for a detailed breakdown of what taint mode tracks."
msgstr ""
"El modo Taint es un set de chequeos de seguridad que Perl ejecuta sobre los "
"datos de entrada a tu programa provinientes de fuentes externas. Los datos "
"de entrada son marcados como \"manchados\" (tainted, no confiables) y pueden "
"o no ser ejecutados en comandos que te permiten tirarte un tiro en tu propio "
"pie. Ver [perlsec manpage](http://perldoc.perl.org/perlsec.html) para "
"obtener un detalle de lo que analiza el modo 'taint'."

#: s/perl.md.tt2:33
msgid "To invoke taint mode:"
msgstr "Para invocar el modo taint:"

#: s/perl.md.tt2:35
msgid ""
"    # From the command line\n"
"    perl -T program.pl"
msgstr ""
"    # Desde la línea de comando\n"
"    perl -T program.pl"

#: s/perl.md.tt2:38
msgid ""
"    # At the top of your script\n"
"    #!/usr/bin/perl -T"
msgstr ""
"    # En la parte superior de tu script\n"
"    #!/usr/bin/perl -T"

#: s/perl.md.tt2:41
msgid ""
"When your script trips one of the taint checks your application will issue a "
"fatal error message. For testing purposes `-t` will issue warnings instead "
"of fatal errors. `-t` is not a substitute for `-T`."
msgstr ""
"Cuando tu script no supera uno de los chequeos de 'taint', tu aplicación "
"arrojará un error fatal. Con fines de prueba `-t` arrojará advertencias en "
"lugar de errores fatales. `-t` no es substituto de `-T`."

#: s/perl.md.tt2:46
msgid "Explain how DBI supports taint mode, both inbound and outbound.\n"
msgstr ""
"Explica como DBI suporta el modo 'taint', tanto entrante como saliente.\n"

#: s/php.md.tt2:1
msgid "# PHP"
msgstr "# PHP"

#: s/php.md.tt2:3
msgid ""
"PHP is a little more disorganized than how\n"
"[Perl handles parameters](./perl.html).  The standard [MySQL\n"
"extension][mysql] doesn't support parameterization, although the\n"
"[PostgreSQL extension][pg] does:"
msgstr ""
"PHP es un poco más desorganizado que Perl[Perl handles parameters](./perl."
"html),\n"
"respecto al manejo de parametros. La extensión [MySQL\n"
"extension][mysql] standard no soporta parametrización, aunque la de\n"
" [PostgreSQL extension][pg] si:"

#: s/php.md.tt2:8
msgid ""
"    $result = pg_query_params( $dbh, 'SELECT * FROM users WHERE email = $1', "
"array($email) );"
msgstr ""
"    $result = pg_query_params( $dbh, 'SELECT * FROM users WHERE email = $1', "
"array($email) );"

#: s/php.md.tt2:10
msgid ""
"Note that the query must be in single-quotes or have the `$` escaped\n"
"to avoid PHP trying to parse it as a variable."
msgstr ""
"Nota que la consulta desde estar en comillas simples o tener el signo `$` "
"escapado\n"
"para que evitar que PHP lo interprete como una variable. "

#: s/php.md.tt2:13
msgid ""
"**However**, you should probably be using an abstraction layer.\n"
"The [ODBC][odbc] and [PDO][pdo] extensions both support parameterization\n"
"and multiple databases:"
msgstr ""
"**Sin embargo**, tu deberías estar probablemente usando una capa de "
"abstracción.\n"
"Tanto las extensión [ODBC][odbc] como [PDO][pdo] soportan parametrización\n"
"y múltiples bases de datos:"

#: s/php.md.tt2:17
msgid ""
"[mysql]: http://php.net/manual/en/book.mysql.php\n"
"[pg]: http://www.php.net/manual/en/book.pgsql.php\n"
"[odbc]: http://php.net/manual/en/book.uodbc.php\n"
"[pdo]: http://www.php.net/manual/en/book.pdo.php"
msgstr ""
"[mysql]: http://php.net/manual/en/book.mysql.php\n"
"[pg]: http://www.php.net/manual/en/book.pgsql.php\n"
"[odbc]: http://php.net/manual/en/book.uodbc.php\n"
"[pdo]: http://www.php.net/manual/en/book.pdo.php"

#: s/php.md.tt2:22
msgid "## Using mysqli"
msgstr "## Usando mysqli"

#: s/php.md.tt2:24
msgid "The MySQL Improved extension handles bound parameters."
msgstr "La extensión de MySQL mejorada maneja parametros con límites."

#: s/php.md.tt2:26
msgid ""
"    $stmt = $db->prepare('update people set name = ? where id = ?');\n"
"    $stmt->bind_param('si',$name,$id);\n"
"    $stmt->execute();"
msgstr ""
"    $stmt = $db->prepare('update people set name = ? where id = ?');\n"
"    $stmt->bind_param('si',$name,$id);\n"
"    $stmt->execute();"

#: s/php.md.tt2:30
msgid "## Using ADODB"
msgstr "## Usando ADODB"

#: s/php.md.tt2:32
msgid ""
"ADODB provides a way to prepare, bind and execute all in the same method "
"call."
msgstr ""
"ADODB provee una manera de preparar, ligar y executar en la misma llamada de "
"método."

#: s/php.md.tt2:34
msgid ""
"    $dbConnection = NewADOConnection($connectionString);\n"
"    $sqlResult = $dbConnection->Execute(\n"
"        'SELECT user_id,first_name,last_name FROM users WHERE username=? AND "
"password=?',\n"
"        array($_REQUEST['username'], sha1($_REQUEST['password'])\n"
"    );"
msgstr ""
"    $dbConnection = NewADOConnection($connectionString);\n"
"    $sqlResult = $dbConnection->Execute(\n"
"        'SELECT user_id,first_name,last_name FROM users WHERE username=? AND "
"password=?',\n"
"        array($_REQUEST['username'], sha1($_REQUEST['password'])\n"
"    );"

#: s/php.md.tt2:40
msgid "## Using the ODBC layer"
msgstr "## Usando la capa ODBC"

#: s/php.md.tt2:42
msgid ""
"    $stmt = odbc_prepare( $conn, 'SELECT * FROM users WHERE email = ?' );\n"
"    $success = odbc_execute( $stmt, array($email) );"
msgstr ""
"    $stmt = odbc_prepare( $conn, 'SELECT * FROM users WHERE email = ?' );\n"
"    $success = odbc_execute( $stmt, array($email) );"

#: s/php.md.tt2:45
msgid "Or:"
msgstr "O:"

#: s/php.md.tt2:47
msgid ""
"    $res = odbc_exec($conn, 'SELECT * FROM users WHERE email = ?', "
"array($email));\n"
"    $sth = $dbh->prepare('SELECT * FROM users WHERE email = :email');\n"
"    $sth->execute(array(':email' => $email));"
msgstr ""
"    $res = odbc_exec($conn, 'SELECT * FROM users WHERE email = ?', "
"array($email));\n"
"    $sth = $dbh->prepare('SELECT * FROM users WHERE email = :email');\n"
"    $sth->execute(array(':email' => $email));"

#: s/php.md.tt2:51
msgid "## Using the PDO layer"
msgstr "## Usando la capa PDO"

#: s/php.md.tt2:53
msgid "Here's the long way to do bind parameters."
msgstr "Aquí está la manera larga de ligar parametros."

#: s/php.md.tt2:55
msgid ""
"    $dbh = new PDO('mysql:dbname=testdb;host=127.0.0.1', $user, $password);\n"
"    $stmt = $dbh->prepare('INSERT INTO REGISTRY (name, value) VALUES (:"
"name, :value)');\n"
"    $stmt->bindParam(':name', $name);\n"
"    $stmt->bindParam(':value', $value);"
msgstr ""
"    $dbh = new PDO('mysql:dbname=testdb;host=127.0.0.1', $user, $password);\n"
"    $stmt = $dbh->prepare('INSERT INTO REGISTRY (name, value) VALUES (:"
"name, :value)');\n"
"    $stmt->bindParam(':name', $name);\n"
"    $stmt->bindParam(':value', $value);"

#: s/php.md.tt2:60
msgid ""
"    // insert one row\n"
"    $name = 'one';\n"
"    $value = 1;\n"
"    $stmt->execute();"
msgstr ""
"    // insertar una file\n"
"    $name = 'one';\n"
"    $value = 1;\n"
"    $stmt->execute();"

#: s/php.md.tt2:65
msgid "And a shorter way to pass things in."
msgstr "Y una manera más corta para pasar cosas."

#: s/php.md.tt2:67
msgid ""
"    $dbh = new PDO('mysql:dbname=testdb;host=127.0.0.1', $user, $password);\n"
"    $stmt = $dbh->prepare('UPDATE people SET name = :new_name WHERE id = :"
"id');\n"
"    $stmt->execute( array('new_name' => $name, 'id' => $id) );"
msgstr ""
"    $dbh = new PDO('mysql:dbname=testdb;host=127.0.0.1', $user, $password);\n"
"    $stmt = $dbh->prepare('UPDATE people SET name = :new_name WHERE id = :"
"id');\n"
"    $stmt->execute( array('new_name' => $name, 'id' => $id) );"

#: s/php.md.tt2:71
msgid ""
"Here's a great [tutorial on migrating to PDO for MySQL developers](http://"
"wiki.hashphp.org/PDO_Tutorial_for_MySQL_Developers)."
msgstr ""
"Aquí hay un gran [tutorial para migrar PDO para desarolladores MySQL](http://"
"wiki.hashphp.org/PDO_Tutorial_for_MySQL_Developers)."

#: s/php.md.tt2:73
msgid "# Applications & Frameworks"
msgstr "# Applicaciones y Frameworks"

#: s/php.md.tt2:75
msgid "## CakePHP"
msgstr "## CakePHP"

#: s/php.md.tt2:77
msgid ""
"When using the MVC framework [CakePHP][cakephp], most of your\n"
"database communication will be abstracted away by the Model API.\n"
"Still, it is sometimes necessary to perform manual queries, which\n"
"can be done with [Model::query][cake-model-query]. In order to use\n"
"prepared statements with that method, you just need to pass an\n"
"additional array parameter after the SQL query string.  There are\n"
"two variants:"
msgstr ""
"Cuando usas un framework MVC [CakePHP][cakephp], la mayoría de tu\n"
"comunicación con base de datos, será abstraída por la API del Modelo.\n"
"Igualmente, en ocasiones es necesario ejecutar consultas de manera manual\n"
"que puede ser hechas con [Model::query][cake-model-query]. Para hacer\n"
"uso de las sentencias preparadas con este metodo, sólo debés enviar un\n"
"parámeto adicional del vector despues de la cadena de SQL. Existen dos\n"
"variantes:"

#: s/php.md.tt2:85
msgid ""
"    // Unnamed placeholders: Pass an array containing one element for "
"each ?\n"
"    $this->MyModel->query(\n"
"        'SELECT name FROM users WHERE id = ? AND status = ?',\n"
"        array($id, $status)\n"
"    );"
msgstr ""
"    // Placeholders sin nombre: Pasa un array con un elemento para cada "
"signo ?\n"
"    $this->MyModel->query(\n"
"        'SELECT name FROM users WHERE id = ? AND status = ?',\n"
"        array($id, $status)\n"
"    );"

#: s/php.md.tt2:91
msgid ""
"    // Named placeholders: Pass an associative array\n"
"    $this->MyModel->query(\n"
"        'SELECT name FROM users WHERE id = :id AND status = :status',\n"
"        array('id' => $id, 'status' => $status)\n"
"    );"
msgstr ""
"    // Placeholders con nombres: Pasa un vector asociativo\n"
"    $this->MyModel->query(\n"
"        'SELECT name FROM users WHERE id = :id AND status = :status',\n"
"        array('id' => $id, 'status' => $status)\n"
"    );"

#: s/php.md.tt2:97
msgid ""
"This behavior is documented in the [CakePHP Cookbook][cake-cookbook].\n"
"(It is described for the `fetchAll()`-method, but `query()` uses\n"
"`fetchAll()` internally)."
msgstr ""
"Este comportamiento está documentado en [CakePHP Cookbook][cake-cookbook].\n"
"(Esta descripto para el `fetchAll()`-method, pero `query()` usa\n"
"`fetchAll()` internamente)."

#: s/php.md.tt2:101
msgid ""
"[cakephp]: http://cakephp.org/\n"
"[cake-model-query]: http://api.cakephp.org/class/model#method-Modelquery\n"
"[cake-cookbook]: http://book.cakephp.org/2.0/en/models/retrieving-your-data."
"html#prepared-statements"
msgstr ""
"[cakephp]: http://cakephp.org/\n"
"[cake-model-query]: http://api.cakephp.org/class/model#method-Modelquery\n"
"[cake-cookbook]: http://book.cakephp.org/2.0/en/models/retrieving-your-data."
"html#prepared-statements"

#: s/php.md.tt2:105
msgid "## WordPress"
msgstr "## WordPress"

#: s/php.md.tt2:107
msgid ""
"If your site/blog/application is running on [WordPress][WP], you\n"
"can use the `prepare` method of the `$wpdb` class, which supports\n"
"both a sprintf()-like and vsprintf()-like syntax."
msgstr ""
"Si tu sitio/blog/aplicación esta corriedo sobre [WordPress][WP], tu\n"
"puedes usar el método `prepare` the la clase `$wpdb`, que soporta\n"
"una sintaxis similar tanto a sprintf() como a vsprintf(). "

#: s/php.md.tt2:111
msgid ""
"    global $wpdb;\n"
"    $wpdb->query(\n"
"        $wpdb->prepare( \"SELECT name FROM people WHERE id = %d OR email = %s"
"\",\n"
"            $person_id, $person_email\n"
"        )\n"
"    );"
msgstr ""
"    global $wpdb;\n"
"    $wpdb->query(\n"
"        $wpdb->prepare( \"SELECT name FROM people WHERE id = %d OR email = %s"
"\",\n"
"            $person_id, $person_email\n"
"        )\n"
"    );"

#: s/php.md.tt2:118
msgid ""
"For INSERTs, UPDATEs, and DELETEs, you can use the handy helper methods in "
"the class, which allow you to specify the format of the submitted values."
msgstr ""
"Para INSERTs, UPDATEs, and DELETEs, puedes usar los métodos de ayuda en la "
"clase (helper methods), que permite especificar el formato de los valores "
"enviados."

#: s/php.md.tt2:120
msgid ""
"    global $wpdb;\n"
"    $wpdb->insert( 'people',\n"
"            array(\n"
"                'person_id' => '123',\n"
"                'person_email' => 'bobby@tables.com'\n"
"            ),\n"
"        array( '%d', '%s' )\n"
"    );"
msgstr ""
"    global $wpdb;\n"
"    $wpdb->insert( 'people',\n"
"            array(\n"
"                'person_id' => '123',\n"
"                'person_email' => 'bobby@tables.com'\n"
"            ),\n"
"        array( '%d', '%s' )\n"
"    );"

#: s/php.md.tt2:129
msgid "More details on the [WordPress Codex][codex]."
msgstr "Más detalles en [WordPress Codex][codex]."

#: s/php.md.tt2:131
msgid ""
"[WP]: http://wordpress.org/\n"
"[codex]: http://codex.wordpress.org/Class_Reference/wpdb\n"
msgstr ""
"[WP]: http://wordpress.org/\n"
"[codex]: http://codex.wordpress.org/Class_Reference/wpdb\n"

#: s/plsql.md.tt2:1
msgid ""
"PL/SQL\n"
"======"
msgstr ""
"PL/SQL\n"
"======"

#: s/plsql.md.tt2:4
msgid "Examples assume the following table structure:"
msgstr "Los ejemplos asumen la siguiente estructura de tabla:"

#: s/plsql.md.tt2:6
msgid ""
"    CREATE TABLE users (\n"
"        username VARCHAR2(8) UNIQUE,\n"
"        accessed_at DATE,\n"
"        superuser NUMBER(1,0)\n"
"    );"
msgstr ""
"    CREATE TABLE users (\n"
"        username VARCHAR2(8) UNIQUE,\n"
"        accessed_at DATE,\n"
"        superuser NUMBER(1,0)\n"
"    );"

#: s/plsql.md.tt2:12
msgid ""
"    INSERT INTO users VALUES ('janihur',  sysdate,      0);\n"
"    INSERT INTO users VALUES ('petdance', sysdate - 12, 1);\n"
"    INSERT INTO users VALUES ('albundy',  sysdate - 3,  0);\n"
"    INSERT INTO users VALUES ('donduck',  sysdate - 18, 0);"
msgstr ""
"    INSERT INTO users VALUES ('janihur',  sysdate,      0);\n"
"    INSERT INTO users VALUES ('petdance', sysdate - 12, 1);\n"
"    INSERT INTO users VALUES ('albundy',  sysdate - 3,  0);\n"
"    INSERT INTO users VALUES ('donduck',  sysdate - 18, 0);"

#: s/plsql.md.tt2:17
msgid ""
"Always prefer static SQL when possible\n"
"--------------------------------------"
msgstr ""
"Siempre prefiere SQL estático cuando sea posible\n"
"----------------------------------------------"

#: s/plsql.md.tt2:20
msgid "Static SQL leaves no room for SQL injection."
msgstr "SQL estático no da lugar a inyecciones SQL."

#: s/plsql.md.tt2:22
msgid ""
"    CREATE OR REPLACE FUNCTION user_access (\n"
"        p_uname IN VARCHAR2\n"
"    ) RETURN date AS\n"
"        v_accessed_at date;\n"
"    BEGIN\n"
"        SELECT accessed_at INTO v_accessed_at FROM users WHERE username = "
"p_uname;\n"
"        RETURN v_accessed_at;\n"
"    END;\n"
"    /"
msgstr ""
"    CREATE OR REPLACE FUNCTION user_access (\n"
"        p_uname IN VARCHAR2\n"
"    ) RETURN date AS\n"
"        v_accessed_at date;\n"
"    BEGIN\n"
"        SELECT accessed_at INTO v_accessed_at FROM users WHERE username = "
"p_uname;\n"
"        RETURN v_accessed_at;\n"
"    END;\n"
"    /"

#: s/plsql.md.tt2:32 s/plsql.md.tt2:64 s/plsql.md.tt2:94
msgid ""
"\n"
"    SELECT user_access('janihur')\n"
"      AS \"JANIHUR LAST SEEN\" FROM DUAL;"
msgstr ""
"\n"
"    SELECT user_access('janihur')\n"
"      AS \"JANIHUR LAST SEEN\" FROM DUAL;"

#: s/plsql.md.tt2:36 s/plsql.md.tt2:68 s/plsql.md.tt2:98
msgid ""
"    JANIHUR LAST SEEN\n"
"    -------------------\n"
"    2011-08-03 17:11:24"
msgstr ""
"    JANIHUR LAST SEEN\n"
"    -------------------\n"
"    2011-08-03 17:11:24"

#: s/plsql.md.tt2:40 s/plsql.md.tt2:72 s/plsql.md.tt2:102
msgid ""
"    SELECT user_access('whocares'' or superuser = 1 or username = "
"''whocares') \n"
"      AS \"SUPERUSER LAST SEEN\" FROM DUAL;"
msgstr ""
"    SELECT user_access('whocares'' or superuser = 1 or username = "
"''whocares') \n"
"      AS \"SUPERUSER LAST SEEN\" FROM DUAL;"

#: s/plsql.md.tt2:43 s/plsql.md.tt2:105
msgid ""
"    SUPERUSER LAST SEEN\n"
"    -------------------"
msgstr ""
"    SUPERUSER LAST SEEN\n"
"    -------------------"

#: s/plsql.md.tt2:46
msgid ""
"\n"
"If you need dynamic SQL avoid string concatenation when possible\n"
"----------------------------------------------------------------"
msgstr ""
"\n"
"Si necesitas SQL dinámico evita concatenacion de cadenas de caracteres "
"cuando sea posible\n"
"--------------------------------------------------------------------------------------"

#: s/plsql.md.tt2:50
msgid "String concatenation opens doors to possible SQL injection exploits:"
msgstr ""
"Concatenacion de strings abre las puertas a vulnerabilidades de inyección de "
"SQL:"

#: s/plsql.md.tt2:52
msgid ""
"    CREATE OR REPLACE FUNCTION user_access (\n"
"        p_uname IN VARCHAR2\n"
"    ) RETURN date AS\n"
"        v_accessed_at date;\n"
"        v_query constant varchar2(32767) := \n"
"          'SELECT accessed_at FROM users WHERE username = ''' || p_uname || "
"'''';\n"
"    BEGIN\n"
"        EXECUTE IMMEDIATE v_query INTO v_accessed_at;\n"
"        RETURN v_accessed_at;\n"
"    END;\n"
"    /"
msgstr ""
"    CREATE OR REPLACE FUNCTION user_access (\n"
"        p_uname IN VARCHAR2\n"
"    ) RETURN date AS\n"
"        v_accessed_at date;\n"
"        v_query constant varchar2(32767) := \n"
"          'SELECT accessed_at FROM users WHERE username = ''' || p_uname || "
"'''';\n"
"    BEGIN\n"
"        EXECUTE IMMEDIATE v_query INTO v_accessed_at;\n"
"        RETURN v_accessed_at;\n"
"    END;\n"
"    /"

#: s/plsql.md.tt2:75
msgid ""
"    SUPERUSER LAST SEEN\n"
"    -------------------\n"
"    2011-07-22 17:11:24"
msgstr ""
"    SUPERUSER LAST SEEN\n"
"    -------------------\n"
"    2011-07-22 17:11:24"

#: s/plsql.md.tt2:79
msgid "Instead use bind variables:"
msgstr "En su lugar utiliza variables ligadas:"

#: s/plsql.md.tt2:81
msgid ""
"\n"
"    CREATE OR REPLACE FUNCTION user_access (\n"
"        p_uname IN VARCHAR2\n"
"    ) RETURN date AS\n"
"        v_accessed_at date;\n"
"        v_query constant varchar2(32767) := \n"
"          'SELECT accessed_at FROM users WHERE username = :a';\n"
"    BEGIN\n"
"        EXECUTE IMMEDIATE v_query INTO v_accessed_at USING p_uname;\n"
"        RETURN v_accessed_at;\n"
"    END;\n"
"    /"
msgstr ""
"\n"
"    CREATE OR REPLACE FUNCTION user_access (\n"
"        p_uname IN VARCHAR2\n"
"    ) RETURN date AS\n"
"        v_accessed_at date;\n"
"        v_query constant varchar2(32767) := \n"
"          'SELECT accessed_at FROM users WHERE username = :a';\n"
"    BEGIN\n"
"        EXECUTE IMMEDIATE v_query INTO v_accessed_at USING p_uname;\n"
"        RETURN v_accessed_at;\n"
"    END;\n"
"    /"

#: s/plsql.md.tt2:108
msgid ""
"Implicit Data Type Conversion Injection\n"
"---------------------------------------"
msgstr ""
"Inyección mediante conversion de tipos de datos\n"
"--------------------------------------------"

#: s/plsql.md.tt2:111
msgid ""
"Also NLS session parameters (`NLS_DATE_FORMAT`, `NLS_TIMESTAMP_FORMAT`, "
"`NLS_TIMESTAMP_TZ_FORMAT`, `NLS_NUMERIC_CHARACTER`) can be used to modify or "
"inject SQL statements."
msgstr ""
"También los parámetros de sesión NLS (`NLS_DATE_FORMAT`, "
"`NLS_TIMESTAMP_FORMAT`, `NLS_TIMESTAMP_TZ_FORMAT`, `NLS_NUMERIC_CHARACTER`)  "
"pueden ser usados para modificar o inyectar sentencias SQL."

#: s/plsql.md.tt2:113
msgid ""
"In next example data type conversion takes place when `p_since` is "
"implicitly converted to a string for concatenation. Note how the value of "
"`NLS_DATE_FORMAT` affects to the query string in `users_since()` function!"
msgstr ""
"En el próximo ejemplo la conversión del tipo de datos tiene lugar cuando "
"`p_since` es implicitamente convertido a una cadena de caracteres para la "
"concatenación. Nota como el valor de `NLS_DATE_FORMAT` afecta la cadena de "
"consulta en la funcion `users_since()`!"

#: s/plsql.md.tt2:115 s/plsql.md.tt2:163
msgid "    ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS';"
msgstr "    ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS';"

#: s/plsql.md.tt2:117 s/plsql.md.tt2:165
msgid ""
"    CREATE OR REPLACE TYPE userlist_t AS TABLE OF VARCHAR2(8);\n"
"    /"
msgstr ""
"    CREATE OR REPLACE TYPE userlist_t AS TABLE OF VARCHAR2(8);\n"
"    /"

#: s/plsql.md.tt2:120
msgid ""
"    CREATE OR REPLACE FUNCTION users_since(\n"
"        p_since IN DATE\n"
"    ) RETURN userlist_t PIPELINED AS\n"
"        v_users userlist_t;\n"
"        v_query constant varchar2(32767) := \n"
"          'SELECT username FROM users WHERE superuser = 0 and accessed_at > "
"''' || p_since || ''' order by accessed_at desc';\n"
"    BEGIN\n"
"        DBMS_OUTPUT.PUT_LINE('v_query = ' || v_query);\n"
"        EXECUTE IMMEDIATE v_query BULK COLLECT INTO v_users;"
msgstr ""
"    CREATE OR REPLACE FUNCTION users_since(\n"
"        p_since IN DATE\n"
"    ) RETURN userlist_t PIPELINED AS\n"
"        v_users userlist_t;\n"
"        v_query constant varchar2(32767) := \n"
"          'SELECT username FROM users WHERE superuser = 0 and accessed_at > "
"''' || p_since || ''' order by accessed_at desc';\n"
"    BEGIN\n"
"        DBMS_OUTPUT.PUT_LINE('v_query = ' || v_query);\n"
"        EXECUTE IMMEDIATE v_query BULK COLLECT INTO v_users;"

#: s/plsql.md.tt2:130 s/plsql.md.tt2:178
msgid ""
"        FOR i IN v_users.FIRST .. v_users.LAST LOOP\n"
"          PIPE ROW(v_users(i));\n"
"        END LOOP;"
msgstr ""
"        FOR i IN v_users.FIRST .. v_users.LAST LOOP\n"
"          PIPE ROW(v_users(i));\n"
"        END LOOP;"

#: s/plsql.md.tt2:134 s/plsql.md.tt2:182
msgid ""
"        RETURN;\n"
"    END;\n"
"    /"
msgstr ""
"        RETURN;\n"
"    END;\n"
"    /"

#: s/plsql.md.tt2:138
msgid ""
"\n"
"    ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD\"SUPRISE!\"';\n"
"    SELECT COLUMN_VALUE AS \"REGULARS\" FROM TABLE(users_since(sysdate - "
"30));"
msgstr ""
"\n"
"    ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD\"SUPRISE!\"';\n"
"    SELECT COLUMN_VALUE AS \"REGULARS\" FROM TABLE(users_since(sysdate - "
"30));"

#: s/plsql.md.tt2:142
msgid ""
"    v_query = SELECT username FROM users WHERE superuser = 0 and accessed_at "
">\n"
"    '2011-07-04SUPRISE!' order by accessed_at desc"
msgstr ""
"    v_query = SELECT username FROM users WHERE superuser = 0 and accessed_at "
">\n"
"    '2011-07-04SUPRISE!' order by accessed_at desc"

#: s/plsql.md.tt2:145
msgid ""
"    REGULARS\n"
"    --------\n"
"    janihur\n"
"    albundy\n"
"    donduck"
msgstr ""
"    REGULARS\n"
"    --------\n"
"    janihur\n"
"    albundy\n"
"    donduck"

#: s/plsql.md.tt2:151
msgid ""
"    ALTER SESSION SET NLS_DATE_FORMAT = '\"'' or superuser = 1 or username = "
"''whocares\"';\n"
"    SELECT COLUMN_VALUE AS \"SUPERUSER IS\" FROM TABLE(users_since(sysdate - "
"30));"
msgstr ""
"    ALTER SESSION SET NLS_DATE_FORMAT = '\"'' or superuser = 1 or username = "
"''whocares\"';\n"
"    SELECT COLUMN_VALUE AS \"SUPERUSER IS\" FROM TABLE(users_since(sysdate - "
"30));"

#: s/plsql.md.tt2:154
msgid ""
"    v_query = SELECT username FROM users WHERE superuser = 0 and accessed_at "
"> ''\n"
"    or superuser = 1 or username = 'whocares' order by accessed_at desc"
msgstr ""
"    v_query = SELECT username FROM users WHERE superuser = 0 and accessed_at "
"> ''\n"
"    or superuser = 1 or username = 'whocares' order by accessed_at desc"

#: s/plsql.md.tt2:157
msgid ""
"    SUPERUSE\n"
"    --------\n"
"    petdance"
msgstr ""
"    SUPERUSE\n"
"    --------\n"
"    petdance"

#: s/plsql.md.tt2:161
msgid ""
"The remedy is to set the format modifier explicitly: `to_char(p_since, 'YYYY-"
"MM-DD')`."
msgstr ""
"EL remedio es setear el modificador de formato explícitamente: "
"`to_char(p_since, 'YYYY-MM-DD')`."

#: s/plsql.md.tt2:168
msgid ""
"    CREATE OR REPLACE FUNCTION users_since(\n"
"        p_since IN DATE\n"
"    ) RETURN userlist_t PIPELINED AS\n"
"        v_users userlist_t;\n"
"        v_query constant varchar2(32767) := \n"
"          'SELECT username FROM users WHERE superuser = 0 and accessed_at > "
"''' || to_char(p_since, 'YYYY-MM-DD') || ''' order by accessed_at desc';\n"
"    BEGIN\n"
"        DBMS_OUTPUT.PUT_LINE('v_query = ' || v_query);\n"
"        EXECUTE IMMEDIATE v_query BULK COLLECT INTO v_users;"
msgstr ""
"    CREATE OR REPLACE FUNCTION users_since(\n"
"        p_since IN DATE\n"
"    ) RETURN userlist_t PIPELINED AS\n"
"        v_users userlist_t;\n"
"        v_query constant varchar2(32767) := \n"
"          'SELECT username FROM users WHERE superuser = 0 and accessed_at > "
"''' || to_char(p_since, 'YYYY-MM-DD') || ''' order by accessed_at desc';\n"
"    BEGIN\n"
"        DBMS_OUTPUT.PUT_LINE('v_query = ' || v_query);\n"
"        EXECUTE IMMEDIATE v_query BULK COLLECT INTO v_users;"

#: s/plsql.md.tt2:186
msgid ""
"Now the value of NLS parameter `NLS_DATE_FORMAT` is ignored during the query."
msgstr ""
"Ahora el valor del parámetro `NLS_DATE_FORMAT` es ignorado durante la "
"consulta."

#: s/plsql.md.tt2:188
msgid ""
"    ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD\"SUPRISE!\"';\n"
"    SELECT COLUMN_VALUE AS \"REGULARS\" FROM TABLE(users_since(sysdate - "
"30));"
msgstr ""
"    ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD\"SUPRISE!\"';\n"
"    SELECT COLUMN_VALUE AS \"REGULARS\" FROM TABLE(users_since(sysdate - "
"30));"

#: s/plsql.md.tt2:191
msgid ""
"    v_query = SELECT username FROM users WHERE superuser = 0 and accessed_at "
">\n"
"    '2011-07-04' order by accessed_at desc"
msgstr ""
"    v_query = SELECT username FROM users WHERE superuser = 0 and accessed_at "
">\n"
"    '2011-07-04' order by accessed_at desc"

#: s/plsql.md.tt2:194
msgid ""
"    REGULARS\n"
"    --------\n"
"    janihur\n"
"    albundy\n"
"    donduck\n"
msgstr ""
"    REGULARS\n"
"    --------\n"
"    janihur\n"
"    albundy\n"
"    donduck\n"

#: s/postgresql.md.tt2:1
msgid ""
"PostgreSQL\n"
"=========="
msgstr ""
"PostgreSQL\n"
"=========="

#: s/postgresql.md.tt2:4
msgid ""
"All of PostgreSQL's [procedural languages](http://www.postgresql.org/docs/"
"current/static/xplang.html), which allow you to write functions and "
"procedures inside the database, allow you to execute arbitrary SQL "
"statements."
msgstr ""
"Todo el [lenguaje de procedimiento](http://www.postgresql.org/docs/current/"
"static/xplang.html) de PostgreSQL, que permite escribir funciones y "
"procedimientos dentro de la base de datos, permite ejectuar sentencias SQL "
"arbitrarias."

#: s/postgresql.md.tt2:6
msgid ""
"PL/pgSQL\n"
"--------"
msgstr ""
"PL/pgSQL\n"
"--------"

#: s/postgresql.md.tt2:9
msgid ""
"The safest way to execute SQL inside a PL/pgSQL statement is just to do so:"
msgstr ""
"La manera más segura de ejectutar SQL dentro de una sentencia PL/pgSQL es "
"sólo hacerlo:"

#: s/postgresql.md.tt2:11
msgid ""
"    CREATE OR REPLACE FUNCTION user_access (p_uname TEXT)\n"
"      RETURNS timestamp LANGUAGE plpgsql AS\n"
"    $func$\n"
"    BEGIN\n"
"        RETURN accessed_at FROM users WHERE username = p_uname;\n"
"    END\n"
"    $func$;"
msgstr ""
"    CREATE OR REPLACE FUNCTION user_access (p_uname TEXT)\n"
"      RETURNS timestamp LANGUAGE plpgsql AS\n"
"    $func$\n"
"    BEGIN\n"
"        RETURN accessed_at FROM users WHERE username = p_uname;\n"
"    END\n"
"    $func$;"

#: s/postgresql.md.tt2:19
msgid ""
"For such a simple case, you're actually better off writing a pure SQL "
"function:"
msgstr ""
"Para un caso tan simple, es mejor si lo escribes en una función pura de SQL:"

#: s/postgresql.md.tt2:21
msgid ""
"    CREATE OR REPLACE FUNCTION user_access (p_uname TEXT)\n"
"      RETURNS timestamp LANGUAGE sql AS\n"
"    $func$\n"
"        SELECT accessed_at FROM users WHERE username = $1\n"
"    $func$;"
msgstr ""
"    CREATE OR REPLACE FUNCTION user_access (p_uname TEXT)\n"
"      RETURNS timestamp LANGUAGE sql AS\n"
"    $func$\n"
"        SELECT accessed_at FROM users WHERE username = $1\n"
"    $func$;"

#: s/postgresql.md.tt2:27
msgid ""
"But sometimes you have to do more complicated things. Perhaps you "
"dynamically add `WHERE` clause expressions based on input. In such a case, "
"you'll end up using PL/pgSQL's [`EXECUTE`](http://www.postgresql.org/docs/"
"current/interactive/plpgsql-statements.html#PLPGSQL-STATEMENTS-EXECUTING-"
"DYN) syntax. Here's an example with an SQL injection vulnerability:"
msgstr ""
"Pero en ocasiones hay que hacer cosas más complicadas. Tal vez añades "
"dinámicamente expresiones de clausulas `WHERE` basadas en la entrada del "
"usuario. EN tal caso, terminarás usando sintáxis PL/pgSQL's [`EXECUTE`]"
"(http://www.postgresql.org/docs/current/interactive/plpgsql-statements."
"html#PLPGSQL-STATEMENTS-EXECUTING-DYN). Aquí hay un ejemplo con una "
"vulnerabilidad de inyección SQL:"

#: s/postgresql.md.tt2:29
msgid ""
"    CREATE OR REPLACE FUNCTION get_users(p_column TEXT, p_value TEXT)\n"
"      RETURNS SETOF users LANGUAGE plpgsql AS\n"
"    $func$\n"
"    DECLARE\n"
"        query TEXT := 'SELECT * FROM users';\n"
"    BEGIN\n"
"        IF p_column IS NOT NULL THEN\n"
"            query := query || ' WHERE ' || p_column\n"
"                  || $_$ = '$_$ || p_value || $_$'$_$;\n"
"        END IF;\n"
"        RETURN QUERY EXECUTE query;\n"
"    END\n"
"    $func$;"
msgstr ""
"    CREATE OR REPLACE FUNCTION get_users(p_column TEXT, p_value TEXT)\n"
"      RETURNS SETOF users LANGUAGE plpgsql AS\n"
"    $func$\n"
"    DECLARE\n"
"        query TEXT := 'SELECT * FROM users';\n"
"    BEGIN\n"
"        IF p_column IS NOT NULL THEN\n"
"            query := query || ' WHERE ' || p_column\n"
"                  || $_$ = '$_$ || p_value || $_$'$_$;\n"
"        END IF;\n"
"        RETURN QUERY EXECUTE query;\n"
"    END\n"
"    $func$;"

#: s/postgresql.md.tt2:43
msgid ""
"Both the `p_column` and the `p_value` arguments are vulnerable. One way to "
"avoid this problem is to use the `quote_ident()` function to quote SQL "
"identifiers (`p_column` in this case) and `quote_lteral()` and quote literal "
"values:"
msgstr ""
"Tanto el argumento `p_column` como `p_value` son vulnerables. Una manera de "
"evitar este problema es utilizar la función `quote_ident()` para citar "
"identificadores SQL (`p_column` en este caso) y `quote_lteral()` con valores "
"de cita literales:"

#: s/postgresql.md.tt2:45
msgid ""
"    CREATE OR REPLACE FUNCTION get_users(p_column TEXT, p_value TEXT)\n"
"      RETURNS SETOF users LANGUAGE plpgsql AS\n"
"    $func$\n"
"    DECLARE\n"
"        query TEXT := 'SELECT * FROM users';\n"
"    BEGIN\n"
"        IF p_column IS NOT NULL THEN\n"
"            query := query || ' WHERE ' || quote_ident(p_column)\n"
"                  || ' = ' || quote_literal(p_value);\n"
"        END IF;\n"
"        RETURN QUERY EXECUTE query;\n"
"    END;\n"
"    $func$;"
msgstr ""
"    CREATE OR REPLACE FUNCTION get_users(p_column TEXT, p_value TEXT)\n"
"      RETURNS SETOF users LANGUAGE plpgsql AS\n"
"    $func$\n"
"    DECLARE\n"
"        query TEXT := 'SELECT * FROM users';\n"
"    BEGIN\n"
"        IF p_column IS NOT NULL THEN\n"
"            query := query || ' WHERE ' || quote_ident(p_column)\n"
"                  || ' = ' || quote_literal(p_value);\n"
"        END IF;\n"
"        RETURN QUERY EXECUTE query;\n"
"    END;\n"
"    $func$;"

#: s/postgresql.md.tt2:59
msgid ""
"It's quite a bit easier to read, too!\n"
"Better yet, employ the `USING` clause of the [`EXECUTE`](http://www."
"postgresql.org/docs/current/interactive/plpgsql-statements.html#PLPGSQL-"
"STATEMENTS-EXECUTING-DYN) command for values (available since v8.4):"
msgstr ""
"Es también un poco más facil de leer!\n"
"Mejor aún, usando la clausula 'USING' del comando para valores [`EXECUTE`]"
"(http://www.postgresql.org/docs/current/interactive/plpgsql-statements."
"html#PLPGSQL-STATEMENTS-EXECUTING-DYN) (disponible desde v8.4):"

#: s/postgresql.md.tt2:62
msgid ""
"    CREATE OR REPLACE FUNCTION get_users(p_column TEXT, p_value TEXT)\n"
"      RETURNS SETOF users LANGUAGE plpgsql AS\n"
"    $func$\n"
"    DECLARE\n"
"        query TEXT := 'SELECT * FROM users';\n"
"    BEGIN\n"
"        IF p_column IS NOT NULL THEN\n"
"            query := query || ' WHERE ' || quote_ident(p_column) || ' = "
"$1';\n"
"        END IF;\n"
"        RETURN QUERY EXECUTE query\n"
"        USING p_value;\n"
"    END;\n"
"    $func$;"
msgstr ""
"    CREATE OR REPLACE FUNCTION get_users(p_column TEXT, p_value TEXT)\n"
"      RETURNS SETOF users LANGUAGE plpgsql AS\n"
"    $func$\n"
"    DECLARE\n"
"        query TEXT := 'SELECT * FROM users';\n"
"    BEGIN\n"
"        IF p_column IS NOT NULL THEN\n"
"            query := query || ' WHERE ' || quote_ident(p_column) || ' = "
"$1';\n"
"        END IF;\n"
"        RETURN QUERY EXECUTE query\n"
"        USING p_value;\n"
"    END;\n"
"    $func$;"

#: s/postgresql.md.tt2:76
msgid ""
"This form avoids the run-time overhead of converting values to text and back "
"in addition to protecting against SQLi."
msgstr ""
"Esta forma evita la sobrecarga en tiempo de ejecución al convertir valores a "
"texto y nuevamente sumado a la protección contra SQLi."

#: s/postgresql.md.tt2:78
msgid ""
"\n"
"PL/Perl\n"
"-------"
msgstr ""
"\n"
"PL/Perl\n"
"-------"

#: s/postgresql.md.tt2:82 s/postgresql.md.tt2:87
msgid "TODO."
msgstr "TODO."

#: s/postgresql.md.tt2:84
msgid ""
"PL/Python\n"
"---------"
msgstr ""
"PL/Python\n"
"---------"

#: s/postgresql.md.tt2:89
msgid "### PL/Tcl"
msgstr "### PL/Tcl"

#: s/postgresql.md.tt2:91
msgid "TODO.\n"
msgstr "TODO.\n"

#: s/python.md.tt2:1
msgid ""
"Python\n"
"======"
msgstr ""
"Python\n"
"======"

#: s/python.md.tt2:4
msgid ""
"Using the [Python DB API](http://wiki.python.org/moin/DatabaseProgramming/), "
"don't do this:"
msgstr ""
"Usando la [Python DB API](http://wiki.python.org/moin/DatabaseProgramming/), "
"no hagas esto:"

#: s/python.md.tt2:6
msgid ""
"    # Do NOT do it this way.\n"
"    cmd = \"update people set name='%s' where id='%s'\" % (name, id)\n"
"    curs.execute(cmd)"
msgstr ""
"    # NO lo hagas de esta manera.\n"
"    cmd = \"update people set name='%s' where id='%s'\" % (name, id)\n"
"    curs.execute(cmd)"

#: s/python.md.tt2:10
msgid "Instead, do this:"
msgstr "En su lugar, haz esto:"

#: s/python.md.tt2:12
msgid ""
"    cmd = \"update people set name=%s where id=%s\"\n"
"    curs.execute(cmd, (name, id))"
msgstr ""
"    cmd = \"update people set name=%s where id=%s\"\n"
"    curs.execute(cmd, (name, id))"

#: s/python.md.tt2:15
msgid "Note that the placeholder syntax depends on the database you are using."
msgstr ""
"Nota que la sintaxis de marcador de posición depende de la base de datos que "
"se use."

#: s/python.md.tt2:17
msgid ""
"    'qmark'         Question mark style,\n"
"                    e.g. '...WHERE name=?'\n"
"    'numeric'       Numeric, positional style,\n"
"                    e.g. '...WHERE name=:1'\n"
"    'named'         Named style,\n"
"                    e.g. '...WHERE name=:name'\n"
"    'format'        ANSI C printf format codes,\n"
"                    e.g. '...WHERE name=%s'\n"
"    'pyformat'      Python extended format codes,\n"
"                    e.g. '...WHERE name=%(name)s'"
msgstr ""
"    'qmark'         Estilo con signo de pregunta,\n"
"                    e.g. '...WHERE name=?'\n"
"    'numeric'       Estilo con posición numérica,\n"
"                    e.g. '...WHERE name=:1'\n"
"    'named'         Estilo nombrado,\n"
"                    e.g. '...WHERE name=:name'\n"
"    'format'        Códigos de formato de printf de ANSI C,\n"
"                    e.g. '...WHERE name=%s'\n"
"    'pyformat'      Códigos extendidos de formato de Python,\n"
"                    e.g. '...WHERE name=%(name)s'"

#: s/python.md.tt2:28
msgid "The values for the most common databases are:"
msgstr "Los valores para las bases de datos más comunes son:"

#: s/python.md.tt2:30
msgid ""
"    >>> import MySQLdb; print MySQLdb.paramstyle\n"
"    format\n"
"    >>> import psycopg2; print psycopg2.paramstyle\n"
"    pyformat\n"
"    >>> import sqlite3; print sqlite3.paramstyle\n"
"    qmark"
msgstr ""
"    >>> import MySQLdb; print MySQLdb.paramstyle\n"
"    format\n"
"    >>> import psycopg2; print psycopg2.paramstyle\n"
"    pyformat\n"
"    >>> import sqlite3; print sqlite3.paramstyle\n"
"    qmark"

#: s/python.md.tt2:37
msgid ""
"So if you are using MySQL or PostgreSQL, use `%s` (even for numbers and\n"
"other non-string values!) and if you are using SQLite use `?`"
msgstr ""
"Entonces si estás usando MySQL o PostgresSQL, us `%s` (incluso para números "
"y \n"
"otros valores no-cadenas-de-caracteres!) y si estás usando SQLite utiliza `?`"

#: s/python.md.tt2:40
msgid ""
"\n"
"To do\n"
"-----"
msgstr ""
"\n"
"To do\n"
"-----"

#: s/python.md.tt2:44 s/ruby.md.tt2:18 s/scheme.md.tt2:18
msgid "-   Add some narrative.\n"
msgstr "-   Añadir más narrativa.\n"

#: s/ruby.md.tt2:1
msgid ""
"Ruby\n"
"===="
msgstr ""
"Ruby\n"
"===="

#: s/ruby.md.tt2:4
msgid ""
"In Ruby on Rails using [ActiveRecord](http://guides.rubyonrails.org/"
"active_record_querying.html):"
msgstr ""
"En Ruby on Rails usando [ActiveRecord](http://guides.rubyonrails.org/"
"active_record_querying.html):"

#: s/ruby.md.tt2:6
msgid "    Person.find :all, :conditions => ['id = ? or name = ?', id, name]"
msgstr "    Person.find :all, :conditions => ['id = ? or name = ?', id, name]"

#: s/ruby.md.tt2:8
msgid "or"
msgstr "o"

#: s/ruby.md.tt2:10
msgid "    Person.find_by_sql ['SELECT * from persons WHERE name = ?', name]"
msgstr "    Person.find_by_sql ['SELECT * from persons WHERE name = ?', name]"

#: s/ruby.md.tt2:12
msgid ""
"\n"
"Using [Ruby/DBI](http://ruby-dbi.rubyforge.org/): analog to [Perl](./perl."
"html)."
msgstr ""
"\n"
"Usando [Ruby/DBI](http://ruby-dbi.rubyforge.org/): análogo a [Perl](./perl."
"html)."

#: s/scheme.md.tt2:1
msgid ""
"Scheme\n"
"======"
msgstr ""
"Scheme\n"
"======"

#: s/scheme.md.tt2:4
msgid ""
"CHICKEN Scheme\n"
"--------------"
msgstr ""
"CHICKEN Scheme\n"
"--------------"

#: s/scheme.md.tt2:7
msgid ""
"[CHICKEN](http://www.call-with-current-continuation.org/) is a compiler for "
"[Scheme](http://schemers.org/)"
msgstr ""
"[CHICKEN](http://www.call-with-current-continuation.org/) es un compilador "
"para [Scheme](http://schemers.org/)"

#: s/scheme.md.tt2:9
msgid ""
"\n"
"    (define DB (sqlite3:open  \"myexample.db\"))\n"
"    (sqlite3:exec DB \"INSERT INTO Person(name) VALUES(?)\" \"Luke Skywalker"
"\")\n"
"    (sqlite3:for-each-row print DB \"SELECT id,name FROM Person WHERE id=?\" "
"3)\n"
"    (define adults (sqlite3:map-row DB \"SELECT name FROM Person WHERE age "
">= ?\" 18))"
msgstr ""
"\n"
"    (define DB (sqlite3:open  \"myexample.db\"))\n"
"    (sqlite3:exec DB \"INSERT INTO Person(name) VALUES(?)\" \"Luke Skywalker"
"\")\n"
"    (sqlite3:for-each-row print DB \"SELECT id,name FROM Person WHERE id=?\" "
"3)\n"
"    (define adults (sqlite3:map-row DB \"SELECT name FROM Person WHERE age "
">= ?\" 18))"

#: s/translations.md.tt2:1
msgid "# Translations"
msgstr "# Traducciones"

#: s/translations.md.tt2:3
msgid "The following natural languages are supported on bobby-tables.com:"
msgstr "Los siguientes lenguajes naturales son soportados por bobby-tables.com"

#: s/translations.md.tt2:5
msgid ""
"* [English](http://bobby-tables.com/) (native)\n"
"* [German](http://bobby-tables.com/de_DE/) (fairly current)\n"
"* [Russian](http://bobby-tables.com/ru_RU/) (just starting)"
msgstr ""
"* [Inglés](http://bobby-tables.com/) (nativo)\n"
"* [Alemán](http://bobby-tables.com/de_DE/) (medianamente actualizado)\n"
"* [Ruso](http://bobby-tables.com/ru_RU/) (recién empezado)"

#: s/translations.md.tt2:9
msgid ""
"We'd love to have translations into other languages as well.  Please contact "
"the [bobby-tables mailing list][1] and ask a team member about how you can "
"help."
msgstr ""
"Nos encantaría tener traducciones a otros idiomas tambien. Por favor "
"contacta la [lista de correo de bobby-tables][1] y pregunta a un miembro "
"como puedes ayudar."

#: s/translations.md.tt2:11
msgid "# Contributing translations"
msgstr "# Contribuyendo a las traducciones"

#: s/translations.md.tt2:13
msgid "1. Run `make messages`."
msgstr "1. Ejecutar `make messages`."

#: s/translations.md.tt2:15
msgid ""
"2. Skip this step if you just amend a translation. If you need to start a "
"new language, copy `share/locale/com.bobby-tables.pot` to `share/locale/"
"xx_YY/LC_MESSAGES/com.bobby-tables.po`, but substitute `xx` for the "
"appropriate [language code][2] and `YY` for the [territory code][3]. "
"(Alternatively to copying, use the command `msginit`.) Naming convention "
"examples:"
msgstr ""
"2. Saltea este paso si sólo estás agregando una traducción. Si necesitas "
"empezar un nuevo lenguaje, copia `share/locale/com.bobby-tables.pot` a "
"`share/locale/xx_YY/LC_MESSAGES/com.bobby-tables.po`, pero substituye `xx` "
"por el [codigo de lenguaje][2] apropiado y `YY` por el [código de territorio]"
"[3]. (Alternativamente a copiar, usa el comando `msginit`.) Ejemplos de "
"convenciones de nombre :"

#: s/translations.md.tt2:17
msgid ""
"        sv_SE.po    standard Swedish\n"
"        pt_BR.po    Brazilian Portuguese"
msgstr ""
"        sv_SE.po    sueco estandar\n"
"        pt_BR.po    portugués brasilero"

#: s/translations.md.tt2:20
msgid ""
"3. Edit the PO file. [Lokalize (formerly KBabel)][Lokalize] is excellent, "
"[Poedit][Poedit] is good. Any text editor supporting UTF-8 can handle PO "
"files, but it will not be as convenient."
msgstr ""
"3. Edita el archivo PO. [Lokalize (antiguamente KBabel)][Lokalize] es "
"excelente, [Poedit][Poedit] es bueno.Cualquier editor de texto con soporte "
"para UTF-8 puede manejar PO files, pero no va a ser tan de conveniente."

#: s/translations.md.tt2:22
msgid "4. Run the normal `make` step."
msgstr "4. Ejecuta el paso normal `make`."

#: s/translations.md.tt2:24
msgid "# Guidelines for translations"
msgstr "# Guía para las traducciones"

#: s/translations.md.tt2:26
msgid ""
"* Become familiar with the source mark-up language [Markdown][Markdown] used "
"for producing the rendered HTML. The backtick (\\`) is an important piece of "
"syntax pertaining to translation, it indicates code, e.g. a variable name, "
"and code is not translated, i.e. copy the source text into the target "
"language as-is. Indented paragraphs are also code.  Translate only comments "
"in such code blocks."
msgstr ""
"* Hazte familiar con el lenguajde de markup del código fuente [Markdown]"
"[Markdown] que se utiliza para producir el HTML. La comilla simple (\\`) es "
"una importante pieza de sintáxis ya que indica código, e.g. el nombre de una "
"variable, y el código no debe ser traducido, i.e. copiar el código de origen "
"al destino tal como se encuentra. Párrafos identados también son código.  "
"Traduce solo los comentarios en estos bloques de código."

#: s/translations.md.tt2:28
msgid ""
"* To find out where a piece of English is from to see the context, run `ack -"
"a 'source text goes here'`. Most of the source text is in directory `s/`. "
"Run `make clean` first to avoid duplicates in build files. (If you don't "
"have [ack][ack] you can use `grep -R`."
msgstr ""
"* Para encontrar donde se encuentra una pieza en inglés, o para ver el "
"contexto, puedes usar `ack -a 'texto de origen aquí'`. La mayoría del texto "
"esta en el directorio `s/`.  Corre `make clean` primero para evadir "
"duplicados en los archivos usados para generar el build (build files). (Si "
"no tienes  [ack][ack] puedes usar  `grep -R`. "

#: s/translations.md.tt2:30
msgid "* You can check your progress by running `make l10n-status`."
msgstr "* Puedes verificar el progreso ejecutando `make l10n-status`."

#: s/translations.md.tt2:32
msgid "Apart from that, the normal rules for any translation apply:"
msgstr "Aparte de esto, las reglas normales para cualquier traducción aplican:"

#: s/translations.md.tt2:34
msgid ""
"* Don't translate literally or word-by-word, instead capture the essence of "
"each sentence/paragraph and reformulate it so it reads naturally. If you "
"have to merge or rearrange sentence parts, do it."
msgstr ""
"* No traduzcas literalmente o palara por palabra, en lugar de eso, captura "
"la escencia de cada oración/párrafo y escribela para que se lea de manera "
"natural. Si tienes que unir o re organizar partes de oraciones, hazlo."

#: s/translations.md.tt2:36
msgid ""
"* Avoid keeping key words/technical jargon in English, consult the standard "
"literature for existing translations of key words. (Software vendors such as "
"Microsoft and KDE publish shared translation tables, import those into your "
"PO editor, too.) In case you find no good translation, use your imagination "
"and put yourself into the position of a member of your potential audience: "
"is the sentence still understandable? If not, add a parenthetical remark to "
"the key word."
msgstr ""
"* Evita mantener la palabras claves/vocabulario técnico en inglés. (Alguna "
"compañias de software como Microsoft o KDE publican tablas de traducción "
"compartidas, importalas a tu editor de PO, también.) En caso de no encontrar "
"una buena traducción, usa la imaginación y ponte en la posición de un "
"miembro de tu audiencia potencial: ¿es la oración todavía entendible? Sino, "
"añade una marca entre paréntesis a la palabra clave."

#: s/translations.md.tt2:38
msgid ""
"* It can happen that source text is wrong in some way (typos, factual "
"errors). This should be improved first in a separate patch, independent from "
"your translation. Fix it yourself, and if not possible (e.g.  because the "
"English text is ambiguous), use `git annotate` to find out who wrote it and "
"ask for clarification."
msgstr ""
"* Puede ocurrir que el texto de origen tenga errores de algún tipo (typos, "
"errores de hecho). Esto debe ser mejorado en una rama ('branch') separada, "
"independiente de tu traducción. Arréglalo por ti mismo, y si no es possible "
"(e.g. porque el texto en inglés es ambiguo), usa `git annotate` para "
"averiguar quien lo escibió y solicitar una clarificación."

#: s/translations.md.tt2:40
msgid ""
"[1]: https://groups.google.com/forum/#!forum/bobby-tables\n"
"[2]: http://en.wikipedia.org/wiki/List_of_ISO_639-1_codes\n"
"[3]: http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\n"
"[ack]: http://betterthangrep.com/\n"
"[Markdown]: http://daringfireball.net/projects/markdown/\n"
"[Lokalize]: http://l10n.kde.org/tools/\n"
"[Poedit]: http://www.poedit.net/\n"
msgstr ""
"[1]: https://groups.google.com/forum/#!forum/bobby-tables\n"
"[2]: http://en.wikipedia.org/wiki/List_of_ISO_639-1_codes\n"
"[3]: http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\n"
"[ack]: http://betterthangrep.com/\n"
"[Markdown]: http://daringfireball.net/projects/markdown/\n"
"[Lokalize]: http://l10n.kde.org/tools/\n"
"[Poedit]: http://www.poedit.net/\n"

#: tt/footer.tt:5
msgid ""
"This site's content is available under the <a href=\"https://creativecommons."
"org/licenses/by-sa/3.0/\">Creative Commons Attribution-ShareAlike 3.0 "
"License</a>"
msgstr ""
"El contenido de este sitio está disponible bajo una licencia<a href="
"\"https://creativecommons.org/licenses/by-sa/3.0/\">Creative Commons "
"Attribution-ShareAlike 3.0 License</a>"

#: tt/footer.tt:8
msgid "Fork me on GitHub"
msgstr "Haz un Fork en GitHub"

#: tt/header.tt:6
msgid "Bobby Tables: A guide to preventing SQL injection"
msgstr "Bobby Tables: Una guía para prevenir inyección de SQL"

#. (currlang)
#: tt/page.tt:6
msgid "bobby-tables.com: A guide to preventing SQL injection in {currlang}"
msgstr ""
"bobby-tables.com: Una guía para prevenir inyección de SQL en {currlang}"

#: tt/page.tt:8
msgid "bobby-tables.com: A guide to preventing SQL injection"
msgstr "bobby-tables.com: Una guía para prevenir la inyeccion de SQL"
